<?php
// $Id: project.module,v 1.239.2.31 2007/09/19 02:16:51 dww Exp $
// $Name:  $

// project nodes    -> project_projects
// project releases -> project_releases

$path = drupal_get_path('module', 'project');
if (file_exists("$path/project.inc")) {
  require_once "$path/project.inc";
  require_once "$path/release.inc";
}

function project_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Provides a project node type and manages downloads of project releases.');
    case 'node/add#project_project':
      return t('A project is anything that has releases which can be downloaded');
    case 'admin/settings/project':
      if (project_use_taxonomy()) {
         return _project_taxonomy_help();
      }
  }
  if (arg(0) == 'admin' && arg(1) == 'taxonomy') {
    $vid = _project_get_vid();
    if (arg(2) == $vid) {
      return _project_taxonomy_help($vid, FALSE);
    }
  }
}

/**
 * Prints out a help message about how to configure the project vocabulary.
 *
 * @param $vid
 *   Vocabulary ID of the project taxonomy.
 * @param $vocab_link
 *   Boolean that controls if a link to the vocabulary admin page is added.
 */
function _project_taxonomy_help($vid = 0, $vocab_link = TRUE) {
  if (!$vid) {
    $vid = _project_get_vid();
  }
  $vocabulary = taxonomy_get_vocabulary($vid);
  $text = '<p>'. t('The project module makes special use of the taxonomy (category) system. A special vocabulary, %vocabulary_name, has been created automatically.', array('%vocabulary_name' => theme('placeholder', $vocabulary->name))) .'</p>';
  $text .= '<p>'. t('To take full advantage of project categorization, add at least two levels of terms to this vocabulary. The first level will be the basic project types, e.g., "Modules", "Themes", "Translations".') .'</p>';
  $text .= '<p>'. t('Subterms of each of these types will be the categories that users can select to classify the projects. For example, "Modules" might have sub-terms including "Mail" and "XML".') .'</p>';
  if ($vocab_link) {
    $text .= '<p>'. t('Use the <a href="@taxonomy-admin">vocabulary admininistration page</a> to view and add terms.', array('@taxonomy-admin' => url('admin/content/taxonomy/'. $vid))) .'</p>';
  }
  return $text;
}

/**
 * Implementation of hook_block().
 */
function project_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Project navigation');
    return $blocks;
  }
  else if ($op == 'view') {
    $uris = NULL;
    $projects = array_merge(array(0 => t('<select a project>')), project_projects_select_options($uris, FALSE, 'node/'));
    $block['subject'] = t('Project navigation');
    $form = project_quick_navigate_form($projects);
    $block['content'] = drupal_get_form('project_quick_navigate_form', $form);

    return $block;
  }
}

function project_node_info() {
  return array(
    'project_project' => array('name' => t('project'), 'base' => 'project_project'),
  );
}

function project_perm() {
  $perms = array(
    'administer projects',
    'maintain projects',
    'access projects',
    'access own projects',
  );
  return $perms;
}

/**
 * Implementation of hook_db_rewrite_sql().
 *
 * Both project (and, if enabled, project_issue) provide some permissions that
 * restrict access to viewing projects (and issues). For these permissions to
 * be globally honored by the system, db_rewrite_sql() has to check what
 * permissions the current user has and restrict query results accordingly.
 *
 * If a user has 'access projects' and 'access project issues', they have full
 * access, so there's nothing to re-write. If they have 'access own projects'
 * and/or 'access own project issues', the resulting query should JOIN on
 * {node} and ensure that the node type is not project_project or
 * project_issue, or that the owner of the node is the current user. If they
 * do not have any access to either, then we can just restrict the query based
 * on the {node}.type column.
 *
 * @see project_perm()
 * @see project_issue_perm()
 * @see project_find_alias()
 */
function project_db_rewrite_sql($query, $primary_table, $primary_field) {
  if ($primary_field == 'nid') {
    $return = array();
    $types = "'project_project'";
    $access_projects = user_access('access projects');
    $admin_projects = user_access('administer projects');
    if (module_exist('project_issue')) {
      $access_issues = user_access('access project issues');
      $access_own_issues = user_access('access own project issues');
      $types .= ", 'project_issue'";
    }
    else {
      $access_issues = TRUE;
      $access_own_issues = TRUE;
    }
    if ($admin_projects || ($access_projects && $access_issues)) {
      // User has full access, nothing to re-write.
      return;
    }
    else {
      // We have to make sure {node} is in the query and know the alias.
      if ($primary_table == 'n' || $primary_table == 'node') {
        // Great, it's the primary table and we already know the alias.
        $alias = $primary_table;
      }
      else {
        // Look for {node} in the query.
        if (!($alias = project_find_alias($query, 'node'))) {
          // Not already in the query, JOIN it.
          $return['join'] = "INNER JOIN {node} pn ON pn.nid = ". $primary_table .'.nid';
          $alias = 'pn';
        }
      }
    }
    // At this point, we know we have to restrict something, and we know what
    // the {node} table's alias is in the query.
    $where = array();

    // First, if the type is not one of the project* ones, we don't care.
    $where[] = "($alias.type NOT IN ($types))";

    // Now, see if the current user can access their own, and allow those.
    global $user;
    $uid = $user->uid;
    if (!$access_projects && user_access('access own projects')) {
      $where[] = "($alias.type = 'project_project' AND $alias.uid = $uid)";
    }
    if (!$access_issues && $access_own_issues) {
      $where[] = "($alias.type = 'project_issue' AND $alias.uid = $uid)";
    }

    // Now that we have all our WHERE clauses, we just OR them all together.
    $return['where'] = implode(' OR ', $where);
    return $return;
  }
}

/**
 * Find the table alias for a table in a query.
 *
 * @param $query
 *   The query to examine for the alias.
 * @param
 *   $table The table to examine for the alias.
 * @return
 *   The alias if it exists, or the name of the table if it's present but not
 *   aliased, or FALSE if the table is not present.
 *
 * @see project_db_rewrite_sql()
 */
function project_find_alias($query, $table) {
  // See if {$table} is already in the query.
  $match = array();
  // This regexp handles many cases:
  // - {$table} can be either in FROM or in a JOIN clause
  // - Query might end immediately after {$table}
  // - Might not have a table alias for {$table}
  $pattern = "@.*(FROM|JOIN)\s+\{$table\}\s*(\S+)?@";
  if (preg_match($pattern, $query, $match)) {
    $keywords = '@(ON|INNER|LEFT|RIGHT|WHERE|ORDER|GROUP|HAVING|LIMIT)@';
    if (!isset($match[2]) || preg_match($keywords, $match[2])) {
      // No alias found, just use $table.
      $alias = $table;
    }
    else {
      // Alias found.
      $alias = $match[2];
    }
  }
  else {
    // Table not in query.
    $alias = FALSE;
  }

  return $alias;
}

/**
 * Callback for the main settings page.
 */
function project_settings() {
  $versions = array(-1 => t('all')) + project_releases_list();
  $sort_methods = drupal_map_assoc(array_keys(module_invoke_all('project_sort_methods', 'methods')));

  $form['releases'] = array('#type' => 'fieldset',
    '#title' => t('Releases'),
    '#collapsible' => TRUE,
  );
  $form['releases']['project_release_directory'] = array(
    '#type' => 'textfield',
    '#title' => t('Release directory'),
    '#default_value' => variable_get('project_release_directory', ''),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t('Leave this blank if project maintainers are to create their own release packages. This is useful if releases are generated by an external tool.'),
  );

  $form['releases']['project_release_unmoderate'] = array(
    '#type' => 'radios',
    '#title' => t('Unmoderate projects with releases'),
    '#default_value' => variable_get('project_release_unmoderate', 0),
    '#options' => array('Disabled', 'Enabled'),
  );

  $form['releases']['project_browse_releases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Browse projects by releases'),
    '#default_value' => variable_get('project_browse_releases', 0),
    '#description' => t('Checking this box will cause the project browsing page to have a version select.'),
  );

  $form['releases']['project_release_overview'] = array(
    '#type' => 'radios',
    '#title' => t('Default release overview'),
    '#default_value' => variable_get('project_release_overview', -1),
    '#options' => $versions,
    '#description' => t('Default release version to list on the overview page'),
  );

  $form['browsing'] = array(
   '#type' => 'fieldset',
    '#title' => t('Browsing options'),
    '#collapsible' => TRUE,
  );

  if (project_use_taxonomy()) {

    // For now, date-based browsing doesn't work once you disable
    // taxonomy (only because the code involved is rather complicated
    // and needs to be majorly refactored and cleaned up).
    $form['browsing']['project_sort_method'] = array(
      '#type' => 'radios',
      '#title' => t('Default sort option'),
      '#default_value' => variable_get('project_sort_method', 'category'),
      '#options' => $sort_methods,
      '#description' => t('Default sorting option to use on the overview page'),
    );
    $form['browsing']['sort_methods'] = array(
      '#type' => 'fieldset',
      '#title' => t('Enabled sorting options'),
    );
    $tree = taxonomy_get_tree(_project_get_vid(), 0 , -1, 1);
    foreach ($tree as $term) {
      $form['browsing']['sort_methods']['project_sort_method_used_' . $term->tid] = array(
        '#type' => 'checkboxes',
        '#title' => $term->name,
        '#default_value' => variable_get('project_sort_method_used_' . $term->tid, array_keys($sort_methods)),
        '#options' => $sort_methods,
        '#description' => t('Sorting options to enable for %term', array('%term' => $term->name))
      );
    }
  }
  $form['browsing']['project_browse_nodes'] = array(
    '#type' => 'select', '#title' => t('Number of projects to list in paged browsing'),
    '#default_value' => variable_get('project_browse_nodes', 30),
    '#options' =>  drupal_map_assoc(array(5, 10, 15, 20, 25, 30, 35, 40, 45, 50)),
    '#description' => t('The default maximum number of projects to list when browsing lists, e.g., by category.')
  );

  if (module_exist('forum') && project_use_taxonomy()) {
    $form['project_support_forum'] = taxonomy_form(_forum_get_vid(), variable_get('project_support_forum', ''), t('Select the support forum for projects'), 'project_support_forum');
  }

  // If the project_sort_method setting has changed, the menu will need to be rebuilt.
  menu_rebuild();
  return $form;
}

function project_cron() {
  if (variable_get('project_release_directory', '') && time() - variable_get('project_release_directory_last', 0) > variable_get('project_release_directory_interval', 6 * 60 * 60)) {
    variable_set('project_release_directory_last', time());
    project_release_cron();
  }
}

/**
 * Returns the vocabulary id for projects.
 */
function _project_get_vid() {
  $vid = variable_get('project_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a project module vocabulary exists.
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module='%s'", 'project'));
    if (!$vid) {
      $edit = array('name' => t('Projects'), 'multiple' => 1, 'hierarchy' => 1, 'relations' => 0, 'module' => 'project', 'nodes' => array('project_project' => 1));
      // If there is already a vocabulary assigned to 'project_project' nodes, use it.
      $vocabularies = taxonomy_get_vocabularies('project_project');
      if (count($vocabularies)) {
        $vocabulary = reset($vocabularies);
        $edit['vid'] = $vocabulary->vid;
      }
      taxonomy_save_vocabulary($edit);
      $vid = $edit['vid'];
    }
    variable_set('project_vocabulary', $vid);
  }

  return $vid;
}

/**
 * Implementation of hook_term_path().
 */
function project_term_path($term) {
  // The path must include the first-level term name for this term.
  $tree = taxonomy_get_tree(_project_get_vid());
  $parents = taxonomy_get_parents_all($term->tid);
  foreach($parents as $parent) {
  $ancestors[] = $parent->tid;
  }
  foreach ($tree as $t) {
    if (in_array($t->tid, $ancestors) && $t->depth == 0) {
      $termname = $t->name;
      if ($term->name == $termname) {
        return "project/$termname";
      }
      break;
    }
  }
  return "project/$termname/category/$term->tid";
}

/**
 * Implementation of hook_taxonomy().
 */
function project_taxonomy($op, $type, $object = NULL) {
  if ($op == 'delete' && $type == 'vocabulary' && $object->vid == _project_get_vid())  {
    variable_del('project_vocabulary');
  }
  elseif ($type == 'term' && $object->vid == _project_get_vid()) {
    menu_rebuild();
  }
}

function project_menu($may_cache) {
  $items = array();
  global $user;

  if ($may_cache) {
    // User pages:
    $access_all = user_access('access projects');
    $access_own = user_access('access own projects');
    $access_admin = user_access('administer projects');
    $access = $access_all || $access_own || $access_admin;

    $items[] = array('path' => 'project',
      'title' => t('projects'),
      'callback' => 'project_page_overview',
      'access' => $access,
      'type' => MENU_NORMAL_ITEM);

    $items[] = array('path' => 'project/goto',
      'title' => t('project navigation'),
      'callback' => 'project_goto',
      'access' => $access,
      'type' => MENU_CALLBACK);

    $items[] = array('path' => 'project/autocomplete',
      'title' => t('autocomplete project'),
      'callback' => 'project_autocomplete',
      'access' => $access,
      'type' => MENU_CALLBACK);

    // Project browsing pages
    if (project_use_taxonomy()) {
      $sort_methods = module_invoke_all('project_sort_methods', 'methods');
      $terms = taxonomy_get_tree(_project_get_vid());
      $releases = variable_get('project_browse_releases', 0);
      foreach ($terms as $i => $term) {
        // Only use the first-level terms.
        if ($term->depth == 0) {
          $items[] = array('path' => 'project/'. $term->name,
                           'title' => $term->name,
                           'access' => $access,
                           'type' => MENU_NORMAL_ITEM,
                           'weight' => $term->weight,
                           'callback arguments' => array($term->name));
          $j = 0;
          $term_methods = array_filter(variable_get('project_sort_method_used_' . $term->tid, $sort_methods));
          foreach ($term_methods as $sort_method) {
            $items[] = array('path' => 'project/' . $term->name . '/'. $sort_method,
                 'title' => t('browse by %sort_method', array('%sort_method' => $sort_method)),
                 'access' => $access,
                 'type' => (($sort_method == variable_get('project_sort_method', 'category') || (($j == 0) && !in_array(variable_get('project_sort_method', 'category'), $term_methods))) ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK),
                 'weight' => ($sort_method == variable_get('project_sort_method', 'category')) ? -10 : $j,
                 'callback arguments' => array($term->name, $sort_method));
            $j++;
          }
        }
      }
    }

    // Developers
    $items[] = array('path' => 'project/developers', 'title' => t('developers'), 'callback' => 'project_developers', 'access' => $access, 'type' => MENU_CALLBACK);

    // CVS messages:
    $items[] = array('path' => 'project/cvs', 'title' => t('CVS'), 'callback' => 'project_cvs', 'access' => $access, 'type' => MENU_CALLBACK);

    // Create projects
    $access = project_project_access('create', NULL);
    $items[] = array('path' => 'node/add/project_project', 'title' => t('project'), 'callback' => 'node_page', 'access' => $access, 'type' => MENU_NORMAL_ITEM);

    // Releases
    if (variable_get('project_release_directory', '')) {
      $access = user_access('administer projects');
      $items[] = array('path' => 'admin/settings/project/reload', 'title' => t('scan for releases'), 'callback' => 'project_release_scan', 'access' => $access, 'type' => MENU_NORMAL_ITEM);
    }
  }
  else {
    theme_add_style(drupal_get_path('module', 'project') .'/project.css');
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      if ($node->type == 'project_project') {
        $items[] = array('path' => 'node/'. arg(1) .'/release', 'title' => t('releases'), 'callback' => 'project_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);

        if (node_access('update', $node)) {
          $items[] = array('path' => 'node/'. arg(1) .'/release/overview', 'title' => t('overview'), 'callback' => 'project_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
        }

        if (!variable_get('project_release_directory', '')) {
          $items[] = array('path' => 'node/'. arg(1) .'/release/add', 'title' => t('add'), 'callback' => 'project_release_submit', 'access' => node_access('update', $node), 'weight' => 1, 'type' => MENU_CALLBACK);
        }
        if (arg(2) == 'release' && is_numeric(arg(4))) {
          $items[] = array('path' => 'node/'. arg(1) .'/release/edit/'. arg(4), 'title' => t('edit'), 'callback' => 'project_release_submit', 'access' => node_access('update', $node), 'weight' => 1, 'type' => MENU_CALLBACK);
          $items[] = array('path' => 'node/'. arg(1) .'/release/delete/'. arg(4), 'title' => t('edit'), 'callback' => 'project_release_submit', 'access' => node_access('update', $node), 'weight' => 1, 'type' => MENU_CALLBACK);
        }
      }
    }
  }

  return $items;
}

/**
 * Implementation of form_alter. This removes the work of
 * taxonomy.module's form_alter() so we can do our own taxonomy
 * selection.
 */
function project_form_alter($form_id, &$form) {
  if ($form_id == 'project_project_node_form') {
    $vid = _project_get_vid();
    if (isset($form['taxonomy'][$vid])) {
      unset($form['taxonomy'][$vid]);
    }
    // If there are no children elements, we should unset the entire
    // thing so we don't end up with an empty fieldset.
    if (!element_children($form['taxonomy'])) {
      unset($form['taxonomy']);
    }

    // If the form has an element for specifying a URL alias, we want
    // to alter it, since we're just going to automatically override
    // the specified value.
    if (isset($form['path'])) {
      $url_alias = $form['path']['path']['#default_value'];
      if (empty($url_alias)) {
        unset($form['path']);
      }
      else {
        unset($form['path']['path']);
        $form['path']['value'] = array(
          '#prefix' => '<div>',
          '#value' => t('Automatically generated path alias: %url', array('%url' => theme('placeholder', $url_alias))),
          '#suffix' => '</div>',
        );
      }
    }
  }
}

/**
 * hook_nodeapi() implementation. This just decides what type of node
 * is being passed, and calls the appropriate type-specific hook.
 * NOTE: there's currently only 1 value left here, but I'm planning to
 * make project_release its own node-type, so we'll probably want to
 * leave this plumbing in place for that... -dww
 *
 * @see project_project_nodeapi().
 */
function project_nodeapi(&$node, $op, $arg) {
  switch ($node->type) {
    case 'project_project':
      project_project_nodeapi($node, $op, $arg);
      break;
  }
}

/**
 * Callback used in the project block to navigate to a requested project, or back to the requested page if no project specified.
 */
function project_goto() {
  if (!empty($_REQUEST['edit']['project_goto'])) {
    unset($_REQUEST['edit']['destination']);
    drupal_goto($_REQUEST['edit']['project_goto']);
  }
  else {
    drupal_goto();
  }
}

function project_page() {
  global $user;

  switch (arg(1)) {
    default:
      project_page_overview();
      break;
  }
}

function project_page_overview($termname = NULL, $sort_method = NULL) {
  global $form_values;

  project_project_set_breadcrumb();
  $sort_methods = module_invoke_all('project_sort_methods', 'methods');

  // Read in requested version, if any.
  if ($_POST['edit']['rid']) {
    $version = $_POST['edit']['rid'];
  }
  else if ($_SESSION['project_version']) {
    $version = $_SESSION['project_version'];
  }
  else {
    $version = variable_get('project_release_overview', -1);
  }
  $form = project_version_filter_form($version);
  $version_form = drupal_get_form('project_version_filter_form', $form);
  if ($_POST['edit']['rid']) {
    $_SESSION['project_version'] = $form_values['rid'];
  }
  if (variable_get('project_browse_releases', 0)) {
    $output .= $version_form;
  }

  // If browsing by taxonomy, only fetch projects for this term.
  if (project_use_taxonomy()) {
    $vid = _project_get_vid();
    if ($termname) {

      $type = db_fetch_object(db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {term_data} t WHERE t.vid = %d AND t.name = '%s'", 't', 'tid'), $vid, $termname));
      // Bad project category passed, return page not found.
      if (!$type) {
        return drupal_not_found();
      }
      if (!$sort_method) {
        // For the default, we use the overall default if enabled for this term, and if not we use the first enabled method.
        $term_methods = array_filter(variable_get('project_sort_method_used_' . $type->tid, $sort_methods));
        $sort_method = in_array(variable_get('project_sort_method', 'category'), $term_methods) ? variable_get('project_sort_method', 'category') : array_shift($term_methods);
      }

      if ($type->description) {
        $output .= '<p>' . filter_xss($type->description) . '</p>';
      }

      $module = $sort_methods[$sort_method];
      // Bad sort method passed, return page not found.
      if (!isset($module)) {
        return drupal_not_found();
      }
      if (module_invoke($module, 'project_sort_methods', 'set term', $sort_method)) {

        $tree = taxonomy_get_tree(_project_get_vid(), $type->tid);

        $terms = array();
        if ($tree) {
          $tids = array();
          if (variable_get('project_browse_releases', 0) && $version != -1) {
            // Find all terms associated with the requested version.
            $result = db_query("SELECT t.tid, COUNT(DISTINCT(n.nid)) AS count FROM {term_node} t INNER JOIN {project_releases} p ON t.nid = p.nid INNER JOIN {node} n ON n.nid = t.nid WHERE (p.version LIKE '%s%%') AND (p.path <> '') AND (n.status = 1) GROUP BY t.tid", $version);
            $tids = array();
            while ($item = db_fetch_object($result)) {
              $tids[$item->tid] = $item->count;
            }
          }
          foreach ($tree as $cterm) {
            if (!variable_get('project_browse_releases', 0) || ($version == -1) || array_key_exists($cterm->tid, $tids)) {
              if ($tids[$cterm->tid]) {
                $cterm->count = $tids[$cterm->tid];
              }
              else {
                // We don't use taxonomy_term_count_nodes() because it includes child terms' counts.
                $result = db_query(db_rewrite_sql('SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.nid = n.nid WHERE n.status = 1 AND t.tid = %d GROUP BY t.tid'), $cterm->tid);
                $term = db_fetch_object($result);
                $cterm->count = $term->c;
              }
              $terms[] = $cterm;
            }
          }
        }

        // Look for a specific category term.
        $tid = (arg(3) && is_numeric(arg(3))) ? arg(3) : project_default_tid();
        // Bad term, return page not found.
        if (!($term = taxonomy_get_term($tid))) {
          return drupal_not_found();
        }

      }
      // The sorting method is not supported by the module, so any term passed is invalid.
      // Return page not found if one is found.
      elseif (arg(3)) {
        return drupal_not_found();
      }

      // Set the default elements that will be used to construct the SQL statement.
      $sql_elements = array(
        'fields' => array(
          'prefix' => 'SELECT ',
          'glue' => ', ',
          'pieces' => array(
            'DISTINCT(n.nid)',
            'n.title',
            'n.sticky',
            'nr.teaser',
            'nr.format',
          )
        ),
        'from' => array(
          'prefix' => ' FROM ',
          'glue' => NULL,
          'pieces' => array(
            '{node} n '
          )
        ),
        'joins' => array(
          'prefix' => '',
          'glue' => ' ',
          'pieces' => array(
            'INNER JOIN {node_revisions} nr ON n.vid = nr.vid',
            'INNER JOIN {project_projects} p ON n.nid = p.nid',
            'LEFT JOIN {term_node} r ON n.nid = r.nid'
          )
        ),
        'wheres' => array(
          'prefix' => ' WHERE ',
          'glue' => ' AND ',
          'pieces' => array(
            'n.status = 1',
            'r.tid = %d'
          )
        ),
        'group_bys' => array(
          'prefix' => ' GROUP BY ',
          'glue' => ', ',
          'pieces' => array(
          )
        ),
        'order_bys' => array(
          'prefix' => ' ORDER BY ',
          'glue' => ', ',
          'pieces' => array(
          )
        ),
        'parameters' => array(
          'prefix' => NULL,
          'glue' => NULL,
          'pieces' => array(
            isset($term) ? $term->tid : $type->tid
          )
        )
      );

      // If the site has enabled issue tracking via the project_issue
      // module, we want to add 1 more field and JOIN to our query so
      // we can provide the link for "Bugs and feature requests"...
      if (module_exist('project_issue')) {
        $sql_elements['fields']['pieces'][] = 'pip.issues';
        $sql_elements['joins']['pieces'][] = 'INNER JOIN {project_issue_projects} pip ON n.nid = pip.nid';
      }

      // Only the 'pieces' are returned; the prefix and glue elements remain unchanged.
      $sql_settings = module_invoke($module, 'project_sort_methods', 'sql_settings', $sort_method);

      if (variable_get('project_browse_releases', 0)) {
        $release_settings = array(
          'fields' => array('pr.path', 'pr.version', 'MAX(pr.changed) AS changed', 'COUNT(*) AS release_count'),
          'joins' => array('INNER JOIN {project_releases} pr ON n.nid = pr.nid'),
          'wheres' => array('pr.status = 1', "pr.path <> ''"),
          'group_bys' => array('n.nid'),
          'parameters' => array($version)
        );
        if ($version != -1) {
          $release_settings['wheres'][] = "pr.version LIKE '%s%%'";
        }
        $sql_settings = array_merge_recursive($sql_settings, $release_settings);
      }

      // Merge in $sql_elements
      if (is_array($sql_settings)) {
        foreach(array_keys($sql_settings) as $key) {
          $sql_elements[$key]['pieces'] = array_merge($sql_elements[$key]['pieces'], $sql_settings[$key]);
          $sql_elements[$key]['pieces'] = array_unique($sql_elements[$key]['pieces']);
        }
      }

      $parameters = $sql_elements['parameters']['pieces'];

      $sql = project_build_query($sql_elements);

      $pager = module_invoke($module, 'project_sort_methods', 'pager', $sort_method);
      if ($pager) {
        $first_field = array_shift($sql_elements['fields']['pieces']);
        if (count($sql_elements['group_bys']['pieces'])) {
          $first_field = 'DISTINCT(' . $sql_elements['group_bys']['pieces'][0] . ')';
          $sql_elements['group_bys']['pieces'] = array();
        }
        $sql_elements['fields']['pieces'] = array("COUNT($first_field)");
        // ORDER BY can screw up COUNT(DISTINCT), and we don't care
        // about the order for the count query.
        unset($sql_elements['order_bys']);
        $count_query = project_build_query($sql_elements);
        $result = pager_query($sql, variable_get('project_browse_nodes', 30), 0, $count_query, $parameters);
      }
      else {
        $result = db_query($sql, $parameters);
      }

      // If we've just switched versions, we may have a term requested but no matching projects.
      // In that case, we returned an uncollapsed fieldset.
      if (module_invoke($module, 'project_sort_methods', 'set term', $sort_method)) {
        $output .= theme('fieldset', array('#title' => t('Categories'), '#collapsible' => TRUE, '#collapsed' =>  (arg(3) && db_num_rows($result)) ? TRUE : FALSE, '#children' => theme('project_term_list', $terms, "project/$termname/$sort_method")));
        if (!arg(3) || !db_num_rows($result)) {
          return $output;
        }
        drupal_set_title(t('%project_type: %category', array('%project_type' => check_plain($type->name), '%category' => theme('placeholder', $term->name))));
      }
    }
    // If taxonomy is enabled but no termname is selected, show a list of terms to choose from.
    else {
      $tree = taxonomy_get_tree($vid, 0, -1, 1);
      $items = array();
      foreach ($tree as $term) {
        $items[] = theme('project_type', $term);
      }
      drupal_set_title(t('Project types'));
      return theme('item_list', $items);
    }
  }
  // If taxonomy is not enabled, fetch all projects
  else {
    // Any terms passed without taxonomy module enabled are bogus -- return page not found.
    if (isset($termname)) {
      return drupal_not_found();
    }
    // If the site has enabled issue tracking via the project_issue
    // module, we want to add 1 more field and JOIN to our query so
    // we can provide the link for "Bugs and feature requests"...
    if (module_exist('project_issue')) {
      $ISSUES = ', pip.issues';
      $ISSUE_JOIN ='INNER JOIN {project_issue_projects} pip ON n.nid = pip.nid';
    }
    $result = db_query(db_rewrite_sql("SELECT n.nid, n.title, nr.teaser, nr.format$ISSUES FROM {node} n INNER JOIN {node_revisions} nr ON n.vid = nr.vid $ISSUE_JOIN WHERE n.status = 1 AND n.type = 'project_project' ORDER BY n.title ASC"));
  }
  $class = 'even';
  while ($project = db_fetch_object($result)) {
    $project->body = check_markup($project->teaser, $project->format, FALSE);
    if (module_exist('taxonomy')) {
      $project->taxonomy = taxonomy_node_get_terms($project->nid);
      if (isset($type)) {
         // Hide the top-level project type term from the links, but add it to
         // the $project object for theme_project_summary() to use if it wants.
        unset($project->taxonomy[$type->tid]);
        $project->term = $termname;
      }
      $project->terms = taxonomy_link('taxonomy terms', $project);
    }

    // Make sure we have the latest release
    if ($project->release_count > 1) {
      $latest = db_fetch_object(db_query_range("SELECT path, version FROM {project_releases} WHERE nid = %d AND version LIKE '%s%%' ORDER BY version DESC", $project->nid, $version, 0, 1));
      $project->path = $latest->path;
      $project->version = $latest->version;
    }

    $project->links = array();

    if ($project->path) {
      $project->links[] = '<a href="'. base_path() . $project->path .'">' . t('Download') . '</a>';
    }
    $project->links[] = l(t('Find out more'), "node/$project->nid");

    if ($project->issues) {
      $project->links[] = l(t('Bugs and feature requests'), "project/issues/$project->nid");
    }
    if (module_invoke($module, 'project_sort_methods', 'group by date', $sort_method) && $date = _project_date($project->changed)) {
      $projects .= "<h3>$date</h3>";
    }
    $project->class = ($class == 'even') ? 'odd': 'even';
    $projects .= theme('project_summary', $project);
    $class = $project->class;
  }

  $output .= '<div class="project" id="project-overview">' . $projects . '</div>';

  if ($pager) {
    $output .= theme('pager', NULL, variable_get('project_browse_nodes', 30));
  }
  return $output;
}

function project_build_query($sql_elements) {
  foreach ($sql_elements as $key => $sql_element) {
    if ($key != 'parameters' && count($sql_element['pieces'])) {
      $sql .= $sql_element['prefix'] . implode($sql_element['glue'], $sql_element['pieces']);
    }
  }
  return db_rewrite_sql($sql);
}

// TODO: this should probably be moved to cvs.module...
function project_user($type, $edit, &$user, $category = NULL) {
  if ($type == 'view') {
    if ($projects = module_invoke('cvs', 'get_contributed_projects', $user->uid)) {
      return array(t('Projects') => $projects);
    }
  }
}

/**
 * Provide settings data related to methods for sorting projects.
 *
 */
function project_project_sort_methods($op, $method = NULL) {
  switch ($op) {
    // A listing of the available sorting methods.
    // The array values are the name of the module (in this case, 'project').
    case 'methods':
      $methods = array();
      $methods['name'] = 'project';
      $methods['date'] = 'project';
      if (project_use_taxonomy()) {
        $methods['category'] = 'project';
      }
      return $methods;
    case 'sql_settings' :
      switch ($method) {
        case 'category':
          return array(
            'order_bys' => array('n.sticky DESC', 'n.title ASC')
          );
        case 'date':
          return array(
            'fields' => array('MAX(pr.changed) AS changed'),
            'joins' => array('INNER JOIN {project_releases} pr ON n.nid = pr.nid'),
            'group_bys' => array('n.nid'),
            'order_bys' => array('pr.changed DESC', 'n.sticky DESC', 'n.title ASC')
          );
        case 'name':
          return array(
            'order_bys' => array('n.title ASC', 'n.sticky DESC')
          );
        default:
          return;
      }
    // Does this method reset the $term variable, and output term information?
    case 'set term':
      switch ($method) {
        case 'category':
          return TRUE;
        default:
          return;
      }
    // Does this method page results?
    case 'pager':
      switch ($method) {
        case 'category':
        case 'date':
          return TRUE;
        case 'name':
          return FALSE;
      }
    // Does this method group results by date?
    case 'group by date':
      switch ($method) {
        case 'category':
          return FALSE;
        case 'date':
          return TRUE;
        case 'name':
          return FALSE;
        default:
          return;
      }
  }
  return;
}

function project_default_tid() {
  static $tid;
  if ($tid === NULL) {
    if (variable_get('project_release_overview', -1) != -1) {
      $tid = db_result(db_query("SELECT t.tid FROM {term_node} t INNER JOIN {project_releases} p ON t.nid = p.nid WHERE (p.version LIKE '%s%%')", $version));
    }
    else {
      $tid = db_result(db_query("SELECT t.tid FROM {term_node} t INNER JOIN {project_releases} p ON t.nid = p.nid"));
    }
  }
  return $tid;
}

/**
 * Helper function for grouping nodes by date.
 */
function _project_date($timestamp) {
  static $last;
  $date = format_date($timestamp, 'custom', 'F j, Y');
  if ($date != $last) {
    $last = $date;
    return $date;
  }
}

/**
 * Returns an array of all projects on the system for use with select
 * form elements. The keys are the project nid, and the values are
 * the project names. If the project taxonomy is in use, the array
 * will be sorted into the project categories with appropriate headers
 * for each term.
 *
 * @param $project_urls
 *   Reference to be filled with an array of project uri => id mappings. This
 *   array is used by the project_issue search form code.
 * @param $issues
 *   If TRUE, only projects with issue tracking  enabled are returned.
 *   For this option to do much good, the project_issue.module should be
 *   enabled.
 * @param $key_prefix
 *   Prefix to prepend to all keys in the returned array.
 */
function project_projects_select_options(&$project_urls, $issues = TRUE, $key_prefix = NULL) {
  $projects = array();
  if ($issues && module_exist('project_issue')) {
    $ISSUE_JOIN ='INNER JOIN {project_issue_projects} pip ON n.nid = pip.nid';
    $ISSUE_WHERE = 'AND pip.issues = 1';
  }
  if (project_use_taxonomy()) {
    $vid = _project_get_vid();
    $result = db_query(db_rewrite_sql("SELECT n.nid, n.title, d.name, p.uri FROM {project_projects} p INNER JOIN {node} n ON n.nid = p.nid $ISSUE_JOIN LEFT JOIN {term_node} t ON t.nid = n.nid INNER JOIN {term_data} d ON t.tid = d.tid INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE n.status = 1 $ISSUE_WHERE AND d.vid = %d AND h.parent = 0 GROUP BY n.nid, n.title, d.name, p.uri, d.weight ORDER BY d.weight, n.title"), $vid);
    while ($project = db_fetch_object($result)) {
      if (isset($project->name)) {
        if (!isset($projects[$project->name])) {
          $projects[$project->name] = array();
        }
        $projects[$project->name][$key_prefix . $project->nid] = $project->title;
      }
      else {
        $projects[$key_prefix . $project->nid] = $project->title;
      }
      if (is_array($project_urls)) {
        $project_urls[$project->uri] = $project->nid;
      }
    }
  }
  else {
   $result = db_query(db_rewrite_sql("SELECT n.nid, p.uri, n.title FROM {project_projects} p INNER JOIN {node} n ON n.nid = p.nid $ISSUE_JOIN WHERE n.status = 1 $ISSUE_WHERE ORDER BY n.title"));
    while ($project = db_fetch_object($result)) {
      $projects[$key_prefix . $project->nid] = $project->title;
      if (is_array($project_urls)) {
        $project_urls[$project->uri] = $project->nid;
      }
    }
  }
  return $projects;
}

function project_version_filter_form($version) {
  $releases = array(-1 => t('<all>')) + project_releases_list();
  $form['rid'] = array(
    '#type' => 'select',
    '#default_value' => $version,
    '#options' => $releases
  );
  $form['submit'] = array(
    '#type' => 'button',
    '#value' => t('Go')
  );
  return $form;
}

function theme_project_version_filter_form($form) {
  $output = '<div class="container-inline">' . t('Filter by version:') . form_render($form) . '</div>';
  return $output;
}

function project_quick_navigate_form($projects) {
  $form = array();
  $form['project_goto'] = array(
    '#type' => 'select',
    '#default_value' => '0',
    '#options' => $projects
  );
  $form['destination'] = array(
    '#type' => 'hidden',
    '#value' => $_REQUEST['q']
  );
  $form['submit'] = array(
    '#type' => 'button',
    '#value' => t('Go')
  );
  $form['#action'] = url('project/goto');
  return $form;
}

// Themables

function theme_project_term_list($terms, $path) {
  $depth = 0;
  $output = "\n<ul class=\"project-terms\">\n";
  foreach ($terms as $term) {
    $link = l($term->name .' ('. $term->count .')', "$path/$term->tid", array('title' => strip_tags($term->description)));
    $output .= '<li class="leaf">' . $link . "</li>\n";
  }
  $output .= "\n</ul>\n";
  return $output;
}

/**
 * Theme a compact project view/summary.
 *
 * $project has the following fields:
 * - title: Title
 * - nid: Node id
 * - body: Filtered description
 * - term: String with the selected term name
 * - version: String with the version
 * - links: Array of links
 */
function theme_project_summary($project) {
  $output = '<div class="' . $project->class . '">';
  $output .= '<h2>'. l($project->title, "node/$project->nid") .'</h2>';
  if ($project->changed) {
    $output .= '<p><small>' . t('Last changed: %interval ago', array('%interval' => format_interval(time() - $project->changed, 2))) . '</small></p>';
  }
  $output .= $project->body;
  $output .= theme('links', $project->links);
  if ($project->terms) {
    $output .= '<br />' . theme('links', $project->terms);
  }
  $output .= '</div>';
  return $output;
}

/**
 * Theme a project type item.
 *
 */
function theme_project_type($term) {
  $link = l($term->name, check_url('project/'. $term->name));
  $output = "<div>$link</div>\n";
  if ($term->description) {
    $output .= '<p>' . filter_xss($term->description) . '</p>';
  }
  return $output;
}

/**
 * Returns a string of valid project names formatted to be suitable
 * for use with JS autocomplete fields. The user enters a
 * comma-separated list of project names. We only autocomplete the
 * last one. This code is stolen heavily from taxonomy_autocomplete().
 */
function project_autocomplete($string) {

  // This regexp allows the following types of user input:
  // this, "somecmpany, llc", "and ""this"" w,o.rks", foo bar
  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';
  preg_match_all($regexp, $string, $matches);
  $array = $matches[1];

  // Fetch last project
  $last_string = trim(array_pop($array));

  if ($last_string != '') {
    $result = db_query_range("SELECT n.title FROM {node} n INNER JOIN {project_projects} p ON n.nid = p.nid WHERE LOWER(n.title) LIKE LOWER('%%%s%%')", $last_string, 0, 10);
    $prefix = count($array) ? implode(', ', $array) .', ' : '';
    $matches = array();
    while ($project = db_fetch_object($result)) {
      $t = $project->title;
      $matches[$prefix . $t] = check_plain($project->title);
    }
    print drupal_to_js($matches);
    exit();
  }
}

/**
 * Returns whether or not the project module should use
 * taxonomy-specific functionality.
 */
function project_use_taxonomy() {
  return module_exist('taxonomy') && taxonomy_get_tree(_project_get_vid());
}

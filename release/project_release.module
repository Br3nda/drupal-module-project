<?php
/* $Id: project_release.module,v 1.1.2.5 2006/10/25 00:33:58 dww Exp $ */

function project_release_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Provides a project release node type.');
    case 'node/add#project_release':
      return t('A release of a project with a specific version number.');
  }
}

function project_release_node_info() {
  return array(
    'project_release' => array('name' => t('project release'), 'base' => 'project_release'),
  );
}

/**
 * Implementation of hook_menu()
 */
function project_release_menu($may_cache) {
  $items = array();
  global $user;

  if (!$may_cache) {
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      if ($node->type == 'project_project') {
        $items[] = array('path' => 'node/'. arg(1) .'/release', 'title' => t('releases'), 'callback' => 'project_release_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
        if (node_access('update', $node)) {
          $items[] = array('path' => 'node/'. arg(1) .'/release/overview', 'title' => t('overview'), 'callback' => 'project_release_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
        }
      }
    }
  }
  return $items;
}

/**
 * Implementation of hook_access().
 *
 * TODO: this needs more testing and review. Maybe we should add new
 * permissions for accessing release nodes, but for now, we're just
 * using the existing project perms.
 */
function project_release_access($op, $node) {
  global $user;
  switch ($op) {
    case 'view':
      return user_access('access projects') || (user_access('access own projects') && $node->uid == $user->uid);
    case 'create':
      if (user_access('maintain projects') || user_access('administer projects')) {
        return TRUE;
      }
      return FALSE;
    case 'update':
    case 'delete':
      return $user->uid && ($user->uid == $node->uid || user_access('administer projects'));
  }
}

/**
 * Callback for the main settings page.
 */
function project_release_settings() {
  $versions = array(-1 => t('all')) + project_releases_list();
  // TODO: do we even need the release directory setting anymore?
  $form['project_release_directory'] = array(
    '#type' => 'textfield',
    '#title' => t('Release directory'),
    '#default_value' => variable_get('project_release_directory', ''),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t('Leave this blank if project maintainers are to create their own release packages. This is useful if releases are generated by an external tool.'),
  );

  $form['project_release_default_version_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Default version format string'),
    '#default_value' => variable_get('project_release_default_version_format', '%major.%minor.%patch%extra'),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t('Customize the default format of the version strings for releases of projects on this site. Users with "administer projects" permissions can override this setting for each project.') .' '. t('Available variables are:') .' %super_major, %super_minor, %major, %minor, %patch, %extra.',
  );

  // TODO: isn't this a dead setting, too?
  $form['project_release_unmoderate'] = array(
    '#type' => 'radios',
    '#title' => t('Unmoderate projects with releases'),
    '#default_value' => variable_get('project_release_unmoderate', 0),
    '#options' => array('Disabled', 'Enabled'),
  );

  $form['project_release_overview'] = array(
    '#type' => 'radios',
    '#title' => t('Default release overview'),
    '#default_value' => variable_get('project_release_overview', -1),
    '#options' => $versions,
    '#description' => t('Default release version to list on the overview page'),
  );

  return $form;
}

/**
 * Implementation of hook_form().
 */
function project_release_form(&$release, &$param) {
  if (arg(1) == 'add') {
    if (!is_numeric(arg(3))) {
      $form['markup'] = array(
        '#value' => t('You must add releases only from projects.')
      );
      return $form;
    }
    $release->pid = arg(3);
    $project = node_load($release->pid);
    if (!$project) {
      return drupal_not_found();
    }
    $form['project'] = array(
      '#type' => 'value',
      '#value' => $project,
    );
  }
  else {
    $edit = true;
  }
  $form['#attributes'] = array("enctype" => "multipart/form-data");
 
  $form['title'] = array(
    '#type' => 'value',
    '#default_value' => $release->title,
  );
  $form['version'] = array(
    '#type' => 'value',
    '#default_value' => $release->version,
  );

  // TODO: only provide UI elements for version fields that are
  // specified in the active format string for this project...

  $form['version_major'] = array(
    '#type' => 'textfield',
    '#title' => t('Major version number'),
    '#default_value' => $release->version_major,
    '#size' => 20,
    '#maxlength' => 10,
    '#required' => TRUE,
  );
  if ($edit) {
    $form['version_major']['#attributes'] = array('disabled' => $edit);
  }

  $form['version_minor'] = array(
    '#type' => 'textfield',
    '#title' => t('Minor version number'),
    '#default_value' => $release->version_minor,
    '#size' => 20,
    '#maxlength' => 10,
    '#required' => TRUE,
  );
  if ($edit) {
    $form['version_minor']['#attributes'] = array('disabled' => $edit);
  }

  // TODO: it should be configurable which projects allow this field.
  // Either as a global setting (e.g. a regexp that matches the
  // project somehow) or as a setting in a {project_release_projects}
  // table (which requires 'administer project' perms to see the UI
  // that can alter it per-project)...
  $form['version_patch'] = array(
    '#type' => 'textfield',
    '#title' => t('Patch-level version number'),
    '#default_value' => $release->version_patch,
    '#size' => 20,
    '#maxlength' => 10,
  );
  if ($edit) {
    $form['version_patch']['#attributes'] = array('disabled' => $edit);
  }

  $form['version_extra'] = array(
    '#type' => 'textfield',
    '#title' => t('Extra version identifier'),
    '#default_value' => $release->version_extra,
    '#size' => 20,
    '#maxlength' => 10,
    '#description' => t('Optionally specify other identifying information for this version, for example "rc1" or "dev". In most cases, this should be left blank.'),
  );
  if ($edit) {
    $form['version_extra']['#attributes'] = array('disabled' => $edit);
  }

  if (!variable_get('project_release_directory', '') && empty($release->file_path)) {
    $form['file'] = array(
      '#type' => 'file',
      '#title' => t('File'),
      '#size' => 40,
      '#description' => ($release->file_path) ?
        t('A file already exists, if you upload another file the current file (%file) will be replaced.', array('%file' => $release->file_path)) :
        t('Choose the file that will be associated with this release.'),
    );
  }

  $form['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Changes'),
    '#default_value' => $release->body,
    '#rows' => 10,
    '#cols' => 40,
    '#required' => TRUE,
    '#description' => t('Enter a description of this version, such as a list of the major changes or updates.'),
  );
  $form['format'] = filter_form($node->format);

  $form['pid'] = array(
    '#type' => 'value',
    '#value' => $release->pid,
  );
  $form['tag'] = array(
    '#type' => 'value',
    '#value' => $release->tag,
  );
  $form['rebuild'] = array(
    '#type' => 'value',
    '#value' => $release->rebuild,
  );
  $form['file_hash'] = array(
    '#type' => 'value',
    '#value' => $release->file_hash,
  );
  $form['file_date'] = array(
    '#type' => 'value',
    '#value' => $release->file_date,
  );
  $form['file_path'] = array(
    '#type' => 'value',
    '#value' => $release->file_path,
  );
  $form['version_super_major'] = array(
    '#type' => 'value',
    '#value' => $release->version_super_major,
  );
  $form['version_super_minor'] = array(
    '#type' => 'value',
    '#value' => $release->version_super_minor,
  );
  return $form;
}

/**
 * Implementation of hook_validate().
 */
function project_release_validate(&$edit, $form) {
  $result = db_query("SELECT * FROM {project_release_nodes} WHERE pid = %d AND version_major = %d AND version_minor = %d AND version_patch = %d AND version_extra = '%s' AND version_super_major = %d AND version_super_minor = %d AND nid != %d", $edit->pid, $edit->version_major, $edit->version_minor, $edit->version_patch, $edit->version_extra, $edit->version_super_major, $edit->super_version_minor, $edit->nid);

  if ($release = db_fetch_object($result)) {
     form_set_error('version_minor', t('This version already exists for this project.'));
  }

  if ($file = file_check_upload('file')) {
    $file = file_save_upload('file', file_directory_path());
    if ($file) {
      $filepath = file_create_path($file->filepath);
      form_set_value($form['file_path'], $file->filepath);
      form_set_value($form['file_date'], filemtime($filepath));
      form_set_value($form['file_hash'], md5_file($filepath));
    }
    else {
      form_set_error('file', t('There was a problem uploading the specified file.'));
    }
  }
  if ($edit->project) {
    $version = project_release_get_version((object)$edit, $edit->project);
    form_set_value($form['version'], $version);
    form_set_value($form['title'], t('%project %version', array('%project' => $edit->project->title, '%version' => $version)));
  }
}

/**
 * Implementation of hook_load().
 */
function project_release_load($node) {
  $additions = db_fetch_object(db_query("SELECT * FROM {project_release_nodes} WHERE nid = %d", $node->nid));
  return $additions;
}

/**
 * Implementation of hook_insert().
 */
function project_release_insert($node) {
  db_query("INSERT INTO {project_release_nodes} (nid, pid, version, tag, file_path, file_date, file_hash, rebuild, version_super_major, version_super_minor, version_major, version_minor, version_patch, version_extra) VALUES (%d, %d, '%s', '%s', '%s', %d, '%s', %d, %d, %d, %d, %d, %d, '%s')", $node->nid, $node->pid, $node->version, $node->tag, $node->file_path, $node->file_date, $node->file_hash, $node->rebuild, $node->version_super_major, $node->version_super_minor, $node->version_major, $node->version_minor, $node->version_patch, $node->version_extra);
}

/**
 * Implementation of hook_update().
 */
function project_release_update($node) {
  db_query("UPDATE {project_release_nodes} SET pid = %d, version = '%s', tag = '%s', file_path = '%s', file_date = %d, file_hash = '%s', rebuild = %d, version_super_major = %d, version_super_minor = %d, version_major = %d, version_minor = %d, version_patch = %d, version_extra = '%s' WHERE nid = %d", $node->pid, $node->version, $node->tag, $node->file_path, $node->file_date, $node->file_hash, $node->rebuild, $node->version_super_major, $node->version_super_minor, $node->version_major, $node->version_minor, $node->version_patch, $node->version_extra, $node->nid);
}

/**
 * Implementation of hook_delete().
 */
function project_release_delete($node) {
  if ($node->file_path) {
    file_delete(file_create_path($node->file_path));
  }
  db_query("DELETE FROM {project_release_nodes} WHERE nid = %d", $node->nid);
}

/**
 * Returns the version format string for a given project
 */
function project_release_get_version_format($project) {
  if (!empty($project->version_format)) {
    return $project->version_format;
  }

  $db_format = db_result(db_query("SELECT version_format FROM {project_release_projects} WHERE nid = %d", $project->nid));
  if (!empty($db_format)) {
    return $db_format;
  }

  $admin_setting = variable_get('project_release_default_version_format', FALSE);
  if (!empty($admin_setting)) {
    return $admin_setting;
  }

  return '%major.%minor';
}

/**
 * Returns the formatted version string for a given release node.
 */
function project_release_get_version($release, $project = NULL) {
  if (isset($project)) {	 
    $node = $project;
  }
  else {
    $node->nid = $release->pid;
  }
  $version_format = project_release_get_version_format($node);
  $variables = array(
    '%super_major' => $release->version_super_major,
    '%super_minor' => $release->version_super_minor,
    '%major' => $release->version_major,
    '%minor' => $release->version_minor,
    '%patch' => $release->version_patch,
    '%extra' => $release->version_extra,
  );
  return strtr($version_format, $variables);
}

/**
 * Implementation of hook_view().
 */
function project_release_view(&$release, $teaser = FALSE, $page = FALSE) {
  $project = node_load($release->pid);

  if ($page) {
    // Breadcrumb navigation
    $breadcrumb[] = array('path' => 'node/'. $project->nid, 'title' => $project->title);
    $breadcrumb[] = array('path' => 'node/'. $node->nid, 'title' => $node->title);
    $breadcrumb = project_project_set_location($project, $breadcrumb);
    menu_set_location($breadcrumb);
  }

  $links = array();
  if ($release->file_path) {
    $output .= '<small>' . t('Download: %file', array('%file' => l(basename($release->file_path), file_create_url($release->file_path)))) . '</small><br />';
    $output .= '<small>' . t('Size: %size', array('%size' => format_size(filesize(file_create_path($release->file_path))))) . '</small><br />';
    $output .= '<small>' . t('md5_file file_hash: %file_hash', array('%file_hash' => $release->file_hash)) . '</small><br />';
  }
  if ($release->created) {
    $output .= '<small>' . t('First released: %created', array('%created' => format_date($release->created))) . '</small><br />';
  }
  if ($release->changed  && ($release->changed != $release->created)) {
    $output .= '<small>' . t('Last updated: %changed', array('%changed' => format_date($release->changed))) . '</small><br />';
  }

  $output .= $release->changes;
  $output .= theme('links', $links);

  $release->body .= '<div class="project-release">' . $output . '</div>';
}

/**
 * Display a list of releases for a given project
 */
function project_release_project_releases() {
  $node = node_load(arg(1));

  // Breadcrumb navigation
  $breadcrumb[] = array('path' => 'node/'. $node->nid .'/', 'title' => $node->title);
  $breadcrumb[] = array('path' => 'node/'. arg(1) .'/release', 'title' => t('Releases'));
  $breadcrumb = project_project_set_location($node, $breadcrumb);

  menu_set_location($breadcrumb);

  $output = project_release_list($node);

  drupal_set_title(check_plain($node->title));
  return $output;
}

/**
 * Get an array of release nodes
 */
function project_release_get_releases($project, $nodes = true) {
  $result = db_query(db_rewrite_sql("SELECT n.nid, r.* FROM {node} n INNER JOIN {project_release_nodes} r ON r.nid = n.nid WHERE r.pid = %d ORDER BY n.created DESC"), $project->nid);
  $releases = array();
  while ($obj = db_fetch_object($result)) {
    if ($nodes) {
      $releases[$obj->nid] = node_load($obj->nid);
    }
    else {
      $releases[$obj->nid] = $obj->version;
    }
  }
  return $releases;
}

function project_release_list($project, $main = 0) {
  if ($releases = project_release_get_releases($project)) {
    foreach ($releases as $release) {
      $output .= node_view($release);
    }
    return $output;
  }
}

function project_releases_list($refresh = FALSE) {
  if (!$refresh && ($versions = cache_get('project_releases'))) {
    $versions = unserialize($versions->data);
  }
  else {
    $result = db_query("SELECT version FROM {project_releases} WHERE status = 1 GROUP BY version, created ORDER BY created DESC;");
    $versions = array();
    while ($object = db_fetch_object($result)) {
      $version = preg_replace('/^(.+?)\.?(?:\d+)?$/', '\1', $object->version);
      $versions[$version] = $version == $object->version ? $version : $version .'.x';
    }
    cache_set('project_releases', serialize($versions));
    menu_rebuild();
  }

  return $versions;
}

/**
 * Implementation of hook_form_alter().
 */
function project_release_form_alter($form_id, &$form) {
  if ($form_id == 'project_project_node_form') {
    return project_release_alter_project_form($form);
  }
}

/**
 * Alters the project_project node form to add release settings.
 * @see project_release_form_alter
 */
function project_release_alter_project_form(&$form) {
  $form['release'] = array(
    '#type' => 'fieldset',
    '#title' => t('Release information'),
    '#collapsible' => TRUE,
  );
  $form['release']['releases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable releases'),
    '#return_value' => 1,
    '#weight' => -10,
    '#default_value' => isset($node->releases) ? $node->releases : 1,
    '#description' => t('Allow releases of this project with specific versions.'),
  );
  if (user_access('administer projects')) {
    $form['release']['version_format'] = array(
      '#type' => 'textfield',
      '#title' => t('Version format string'),
      '#default_value' => $node->mail_copy,
      '#size' => 50,
      '#maxlength' => 255,
      '#description' => t('Customize the format of the version strings for releases of this project.') .' '. t('Available variables are:') .' %super_major, %super_minor, %major, %minor, %patch, %extra.',
    );
  }
}

/**
 * hook_nodeapi() implementation. This just decides what type of node
 * is being passed, and calls the appropriate type-specific hook.
 *
 * @see project_release_project_nodeapi().
 */
function project_release_nodeapi(&$node, $op, $arg) {
  switch ($node->type) {
    case 'project_project':
      project_release_project_nodeapi($node, $op, $arg);
      break;
  }
}

/**
 * hook_nodeapi implementation specific to "project_project" nodes
 * (from the project.module)
 * @see project_release_nodeapi().
 */
function project_release_project_nodeapi(&$node, $op, $arg) {
  switch ($op) {
    case 'load':
      $project = db_fetch_object(db_query('SELECT * FROM {project_release_projects} WHERE nid = %d', $node->nid));
      foreach (array('releases', 'version_format') as $field) {
        $node->$field = $project->$field;
      }
      break;

    case 'insert':
      db_query("INSERT INTO {project_release_projects} (nid, releases, version_format) VALUES (%d, %d, '%s')", $node->nid, $node->releases, $node->version_format);
      break;

    case 'update':
      db_query("UPDATE {project_release_projects} SET releases = %d, version_format = '%s' WHERE nid = %d", $node->releases, $node->version_format, $node->nid);
      break;

    case 'delete':
      // TODO: delete all release nodes associated with this project, too.
      db_query('DELETE FROM {project_release_projects} WHERE nid = %d', $node->nid);
      break;
  }
}

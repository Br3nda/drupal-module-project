<?php
/* $Id: project_release.module,v 1.1.2.21 2006/10/25 07:18:33 dww Exp $ */

define('PROJECT_RELEASE_DEFAULT_VERSION_FORMAT', '!major%minor%patch#extra');

/**
 * @defgroup project_release_core Core Drupal hooks
 */

/**
 * Implementation of hook_help().
 * @ingroup project_release_core
 */
function project_release_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Provides a project release node type.');
    case 'node/add#project_release':
      return t('A release of a project with a specific version number.');
  }
}

/**
 * Implementation of hook_menu()
 * @ingroup project_release_core
 */
function project_release_menu($may_cache) {
  $items = array();
  global $user;

  if (!$may_cache) {
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      if ($node->type == 'project_project') {
        $items[] = array('path' => 'node/'. arg(1) .'/release', 'title' => t('releases'), 'callback' => 'project_release_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
        if (node_access('update', $node)) {
          $items[] = array('path' => 'node/'. arg(1) .'/release/overview', 'title' => t('overview'), 'callback' => 'project_release_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
        }
      }
    }
    theme_add_style(drupal_get_path('module', 'project_release') .'/project_release.css');
    project_release_use_taxonomy();
  }
  return $items;
}

/**
 * Callback for the main settings page.
 * @ingroup project_release_core
 */
function project_release_settings() {
  $versions = array(-1 => t('all')) + project_releases_list();
  // TODO: do we even need the release directory setting anymore?
  $form['project_release_directory'] = array(
    '#type' => 'textfield',
    '#title' => t('Release directory'),
    '#default_value' => variable_get('project_release_directory', ''),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t('Leave this blank if project maintainers are to create their own release packages. This is useful if releases are generated by an external tool.'),
  );

  $form['project_release_default_version_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Default version format string'),
    '#default_value' => variable_get('project_release_default_version_format', PROJECT_RELEASE_DEFAULT_VERSION_FORMAT),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t('Customize the default format of the version strings for releases of projects on this site. Users with "administer projects" permissions can override this setting for each project.') .' '. t('Available variables are:') .' %api, %major, %minor, %patch, %extra. '. t("The percent sign ('%') at the front of the variable name indicates that a period ('.') should be inserted as a delimiter before the value of the variable. The '%' can be replaced with a hash mark ('#') to use a hyphen ('-') delimiter, or with an exclaimation point ('!') to have the value printed without a delimiter. Any variable in the format string that has no value will be removed entirely from the final string."),
  );

  // TODO: isn't this a dead setting, too?
  $form['project_release_unmoderate'] = array(
    '#type' => 'radios',
    '#title' => t('Unmoderate projects with releases'),
    '#default_value' => variable_get('project_release_unmoderate', 0),
    '#options' => array('Disabled', 'Enabled'),
  );

  $form['project_release_overview'] = array(
    '#type' => 'radios',
    '#title' => t('Default release overview'),
    '#default_value' => variable_get('project_release_overview', -1),
    '#options' => $versions,
    '#description' => t('Default release version to list on the overview page'),
  );

  return $form;
}


/**
 * @defgroup project_release_node Drupal node-type related hooks 
 */

/**
 * Implementation of hook_access().
 * @ingroup project_release_node
 *
 * TODO: Maybe we should add new permissions for accessing release
 * nodes, but for now, we're just using the existing project perms.
 */
function project_release_access($op, $node) {
  global $user;
  switch ($op) {
    case 'view':
      return user_access('access projects') || (user_access('access own projects') && $node->uid == $user->uid);
    case 'create':
      // We only want to allow creating releases if the project is
      // specified in the URL
      if (is_numeric(arg(3))) {
        return project_release_access_check(arg(3));
      }
      return FALSE;
    case 'update':
      return project_release_access_check($node->pid);
    case 'delete':
      // No one should ever delete a release node, only unpublish it.
      return FALSE;
  }
}

function project_release_access_check($project) {
  global $user;
  if (empty($user->uid)) {
    return FALSE;
  }
  $project_obj = is_numeric($project) ? node_load($project) : $project;
  if (!isset($project_obj) || $project_obj->type != 'project_project') {
    return FALSE;
  }
  if (user_access('administer projects')) {
     return TRUE;
  }
  if (user_access('maintain projects')) {
    if ($user->uid == $project_obj->uid) {
       return TRUE;
    }
    if (module_exist('cvs')) {
      if (db_num_rows(db_query("SELECT * FROM {cvs_project_maintainers} WHERE uid = %d AND nid = %d", $user->uid, $project_obj->nid))) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Implementation of hook_node_info().
 * @ingroup project_release_node
 */
function project_release_node_info() {
  return array(
    'project_release' => array('name' => t('project release'), 'base' => 'project_release'),
  );
}

/**
 * Implementation of hook_form().
 * @ingroup project_release_node
 */
function project_release_form(&$release, &$param) {
  if (arg(1) == 'add') {
    if (!is_numeric(arg(3))) {
      drupal_set_message(t('You can only add releases from a project page.'));
      drupal_not_found();
      module_invoke_all('exit');
      exit;
    }
    $release->pid = arg(3);
    $project = node_load($release->pid);
    if (!isset($project) || $project->type != 'project_project') {
      drupal_set_message(t('Node %nid is not a valid project.', array('%nid' => $release->pid)));
      drupal_not_found();
      module_invoke_all('exit');
      exit;
    }
    $form['project'] = array(
      '#type' => 'value',
      '#value' => $project,
    );
    $format = project_release_get_version_format($project);
  }
  else {
    global $user;
    $admin = user_access('administer projects');
    $is_edit = true;
    $project->nid = $release->pid;
    $format = project_release_get_version_format($project);
  }

  $form['#attributes'] = array("enctype" => "multipart/form-data");
  $form['#prefix'] = '<div class="project-release">';
  $form['#suffix'] = '</div>';
 
  _project_release_form_add_text_element($form['title'], t('Title'), $release->title, $is_edit, $admin);

  _project_release_form_add_text_element($form['version']['version'], t('Version string'), $release->version, $is_edit, $admin);

  $form['pid'] = array(
    '#type' => 'value',
    '#value' => $release->pid,
  );
  $form['version']['num'] = array(
    '#type' => 'fieldset',
    '#title' => t('Version number elements'),
    '#prefix' => '<div class="version-elements">',
    '#suffix' => '</div>',
  );
  $modify = $admin || !$is_edit;
  $form['validate_version'] = array('#type' => 'hidden', '#value' => 1);
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'major', t('Major'));
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'minor', t('Minor'));
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'patch', t('Patch-level'));
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'extra', t('Extra identifier'), t('Optionally specify other identifying information for this version, for example "beta-1", "rc-1" or "dev". In most cases, this should be left blank.'), 40);

  if (!variable_get('project_release_directory', '') && empty($release->file_path)) {
    $form['file']['file'] = array(
      '#type' => 'file',
      '#title' => t('File'),
      '#size' => 40,
      '#description' => ($release->file_path) ?
        t('A file already exists, if you upload another file the current file (%file) will be replaced.', array('%file' => $release->file_path)) :
        t('Choose the file that will be associated with this release.'),
    );
  }

  $form['body_filter']['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $release->body,
    '#rows' => 10,
    '#cols' => 40,
    '#required' => TRUE,
    '#description' => t('Enter a description of this release, such as a list of the major changes or updates.'),
  );
  $form['body_filter']['format'] = filter_form($node->format);

  _project_release_form_add_text_element($form['tag']['tag'], t('Tag'), $release->tag, $is_edit, $admin);
  if ($admin) {
    $form['tag']['rebuild'] = array(
      '#type' => 'checkbox',
      '#title' => t('Rebuild this release regularly?'),
      '#default_value' => $release->rebuild,
    );
  }
  else {
    $form['tag']['rebuild'] = array(
      '#type' => 'value',
      '#value' => $release->rebuild,
    );
  }
  _project_release_form_add_text_element($form['file']['file_path'], t('File path'), $release->file_path, $is_edit, $admin, false);
  _project_release_form_add_text_element($form['file']['file_hash'], t('File md5 hash'), $release->file_hash, $is_edit, false);
  _project_release_form_add_text_element($form['file']['file_date'], t('File date'), $release->file_date, $is_edit, false);

  return $form;
}

/**
 * @defgroup project_release_internal Internal module functions
 */

/**
 * Modifies the given $form array to add the appropriate form element
 * for the requested version field. Since the 20+ lines of code in
 * here have to be duplicated 6 times in project_release_form(), this
 * function exists so we can reuse the code.
 * @see project_release_form
 * @ingroup project_release_internal
 *
 * @param $form Form array to modify
 * @param $release Relase node the form is for
 * @param $modify Boolean indicating if we should allow modifications
 * @param $format Version format string for this project
 * @param $name Name of this version element
 * @param $title Translatable title of the form element
 * @param $description Translatable description of the form element.
 * @param $required Boolean for if the form element should be required
 */
function _project_release_form_add_version_element(&$form, $release, $modify, $format, $name, $title, $description = '', $size = 10) {
  $var_name = 'version_' . $name;
  $regexp = "@.*[!#%]$name.*@";
  if (preg_match($regexp, $format)) {
    $form['version']['num'][$var_name] = array(
      '#type' => 'textfield',
      '#title' => $title,
      '#default_value' => $release->$var_name,
      '#size' => $size,
      '#maxlength' => $size+10,
      '#attributes' => array('style' => 'width:auto'),
    );
    if ($required) {
      // TODO: handle this more flexibly for sites not using CVS
      // perhaps if the format variable is UPPERCASE it's required,
      // and lowercase is optional or something crazy?
      $form[$var_name]['#required'] = TRUE;
    }
    if ($description) {
      $form['version']['num'][$var_name]['#description'] = $description;
    }
    if (!$modify) {
      $form['version']['num'][$var_name]['#attributes'] = array('disabled' => 'disabled');
    }
  }
  else {
    $form['version']['num'][$var_name] = array(
      '#type' => 'value',
      '#value' => $release->$var_name,
    );
  }
}

/**
 * Modifies the given $form array to add the appropriate form element
 * for the desired text field. Since the 16+ lines of code in here
 * have to be duplicated 5 times in project_release_form(), this
 * function exists so we can reuse the code.
 * @see project_release_form
 * @ingroup project_release_internal
 *
 * @param $form Reference to form element to add
 * @param $title Translatable title of the form element
 * @param $value The value to use in the form
 * @param $is_edit Boolean indicating if we're editing or creating
 * @param $admin Boolean for if the edit is by a project administrator
 * @param $required Boolean for if the field should be required
 */
function _project_release_form_add_text_element(&$form, $title, $value, $is_edit, $admin, $required = true) {
  if ($is_edit && !empty($value)) {
    $form = array(
      '#type' => 'textfield',
      '#title' => $title,
      '#default_value' => $value,
      '#required' => $required,
    );
    if(!$admin) {
      $form['#attributes']['disabled'] = 'disabled';
    }
  }
  else {
    $form = array(
      '#type' => 'value',
      '#value' => $value,
    );
  }
}

/**
 * Implementation of hook_validate().
 * @ingroup project_release_node
 */
function project_release_validate(&$edit, $form) {
  if ($_POST['edit']['validate_version']) {
    if (!isset($edit->version_major) && !isset($edit->version_minor) &&
        !isset($edit->version_patch) &&
        (!($edit->version_extra) || $edit->version_extra === '')) {
      form_set_error('version_major', t('You must fill in some version information.'));
      // TODO: find a better form value to mark as the error?
    }
    foreach (array('version_major' => 'Major version number', 'version_minor' => 'Minor version number') as $field => $name) {
      $val = $edit->$field;
      if (isset($val) && $val !== '' && !is_numeric($val)) {
        form_set_error($field, t('%name must be a number.', array('%name' => $name)));
      }
    }
    $val = $edit->version_patch;
    if (isset($val) && $val !== '' && !is_numeric($val) && $val != 'x') {
      form_set_error('version_patch', t("Patch-level version number must be numeric or the letter 'x'."));
    }
  }

  if ($file = file_check_upload('file')) {
    $file = file_save_upload('file', file_directory_path());
    if ($file) {
      $filepath = file_create_path($file->filepath);
      form_set_value($form['file_path'], $file->filepath);
      form_set_value($form['file_date'], filemtime($filepath));
      form_set_value($form['file_hash'], md5_file($filepath));
    }
    else {
      form_set_error('file', t('There was a problem uploading the specified file.'));
    }
  }
  if (project_release_use_taxonomy()) {
    $vid = _project_release_get_api_vid();
    if (isset($edit->taxonomy)) {
      $tid = $edit->taxonomy[$vid];
    }
    elseif (isset($edit->$vid)) {
      $tid = $edit->$vid;
    }
    if (isset($tid) && is_numeric($tid)) {
      $edit->version_api_tid = $tid;
    }
  }

  // With cvs.module installed, this validation is already handled.
  // We only want to do it here if we're *not* doing the N-page form...
  if (!module_exist('cvs') && project_release_exists($edit)) {
    // TODO: is there a better form element to mark with this error?
    form_set_error('version_patch', t('This version already exists for this project.'));
  }

  // TODO: it'd be nice to automagically reset the version string and
  // title based on changes to the version elements on an edit, but we
  // have to be careful not to break the fancy N-page form when
  // cvs_form_alter() is involved...
  if (isset($edit->version) && $edit->version !== '') {
    form_set_value($form['title'], t('%project %version', array('%project' => check_plain($edit->project->title), '%version' => check_plain($edit->version))));
  }
  elseif ($edit->project) {
    $version = project_release_get_version((object)$edit, $edit->project);
    form_set_value(array('#parents' => array('version')), $version);
    form_set_value($form['title'], t('%project %version', array('%project' => $edit->project->title, '%version' => $version)));
  }
}

/**
 * Implementation of hook_load().
 * @ingroup project_release_node
 */
function project_release_load($node) {
  $additions = db_fetch_object(db_query("SELECT * FROM {project_release_nodes} WHERE nid = %d", $node->nid));
  $tid = db_result(db_query("SELECT tn.tid FROM {term_node} tn INNER JOIN {term_data} td ON tn.tid = td.tid WHERE tn.nid = %d", $node->nid));
  $additions->version_api_tid = $tid;
  return $additions;
}

/**
 * Implementation of hook_insert().
 * @ingroup project_release_node
 */
function project_release_insert($node) {
  project_release_db_save($node, true);
}

/**
 * Implementation of hook_update().
 * @ingroup project_release_node
 */
function project_release_update($node) {
  project_release_db_save($node, false);
}

/**
 * Helper method to take data out of a $node object and store it into 
 * the DB as necessary. Sadly, db_query() doesn't let us store NULL in
 * the DB, since those get cast to 0. Therefore, we have to do some 
 * manual effort to dynamically create the appropriate SQL depending
 * on which version fields are set in the release node.
 * @see project_release_insert
 * @see project_release_update
 * @see db_query
 * @ingroup project_release_internal
 *
 * @param $node Node object to save
 * @param $is_new Is this a new release node, or are we updating?
 */
function project_release_db_save($node, $is_new) {
  // If the patch field is set to a non-numeric value, we just want to 
  // keep it as a NULL in the DB, instead of casting it to a 0.
  if (isset($node->version_patch) && !is_numeric($node->version_patch)) {
    unset($node->version_patch);
  }
  $types = array( 'pid' => "%d", 'version' => "'%s'", 'tag' => "'%s'",
    'file_path' => "'%s'", 'file_date' => "%d", 'file_hash' => "'%s'",
    'rebuild' => "%d",
  );
  $values = array( 'pid' => $node->pid, 'version' => $node->version,
    'tag' => $node->tag, 'file_path' => $node->file_path,
    'file_date' => $node->file_date, 'file_hash' => $node->file_hash,
    'rebuild' => $node->rebuild,
  );
  $fields = array('version_major', 'version_minor', 'version_patch');
  foreach ($fields as $field) {
    if (isset($node->$field) && is_numeric($node->$field)) {
      $types[$field] = "%d";
      $values[$field] = $node->$field;
    }
  }
  if (!empty($node->version_extra)) {
    $types['version_extra'] = "'%s'";
    $values['version_extra'] = $node->version_extra;
  }

  if ($is_new) {
    $types['nid'] = "%d";
    $sql = 'INSERT INTO {project_release_nodes} ('. implode(', ', array_keys($types)) .') VALUES ('. implode(', ', $types) .')';
  }
  else {
   $arr = array();
   foreach ($types as $key => $value) {
     $arr[] = $key .' = '. $value;
   }
   $sql = 'UPDATE {project_release_nodes} SET '. implode(',', $arr) .' WHERE nid = %d';
  }
  $values['nid'] = $node->nid;
  db_query($sql, $values);
}

/**
 * Implementation of hook_delete().
 * @ingroup project_release_node
 */
function project_release_delete($node) {
  if ($node->file_path) {
    file_delete(file_create_path($node->file_path));
  }
  db_query("DELETE FROM {project_release_nodes} WHERE nid = %d", $node->nid);
}


/**
 * @defgroup project_release_api Project release functions that other
 * modules might want to use
 */

/**
 * Returns the version format string for a given project
 * @ingroup project_release_api
 */
function project_release_get_version_format($project) {
  if (!empty($project->version_format)) {
    return $project->version_format;
  }

  $db_format = db_result(db_query("SELECT version_format FROM {project_release_projects} WHERE nid = %d", $project->nid));
  if (!empty($db_format)) {
    return $db_format;
  }

  return variable_get('project_release_default_version_format', PROJECT_RELEASE_DEFAULT_VERSION_FORMAT);
}

/**
 * Returns the formatted version string for a given release node.
 * @ingroup project_release_api
 */
function project_release_get_version($release, $project = NULL) {
  if (isset($project)) {
    $node = $project;
  }
  else {
    $node->nid = $release->pid;
  }
  $variables = array();
  foreach (array('major', 'minor', 'patch', 'extra') as $field) {
    $var = "version_$field";
    if (isset($release->$var) && $release->$var !== '') {
      $variables["!$field"] = $release->$var;
      $variables["%$field"] = '.' . $release->$var;
      $variables["#$field"] = '-' . $release->$var;
    }
    else {
      $variables["!$field"] = '';
      $variables["%$field"] = '';
      $variables["#$field"] = '';
    }
  }
  $variables["!api"] = '';
  $variables["%api"] = '';
  $variables["#api"] = '';
  $vid = _project_release_get_api_vid();
  if (project_release_use_taxonomy()) { 
    if (isset($release->version_api_tid)) {
      $tid = $release->version_api_tid;
    }
    elseif (isset($release->$vid)) {
      $tid = $release->$vid;
    }
    if (isset($tid)) {
      $term = taxonomy_get_term($tid);
      $variables["!api"] = $term->name;
      $variables["%api"] = '.' . $term->name;
      $variables["#api"] = '-' . $term->name;
    }
  }
  $version_format = project_release_get_version_format($node);
  return strtr($version_format, $variables);
}

/**
 * Implementation of hook_view().
 * @ingroup project_release_node
 */
function project_release_view(&$release, $teaser = FALSE, $page = FALSE) {
  $project = node_load($release->pid);

  if ($page) {
    // Breadcrumb navigation
    $breadcrumb[] = array('path' => 'node/'. $project->nid, 'title' => $project->title);
    $breadcrumb[] = array('path' => 'node/'. $node->nid, 'title' => $node->title);
    $breadcrumb = project_project_set_location($project, $breadcrumb);
    menu_set_location($breadcrumb);
  }

  $links = array();
  if ($release->rebuild) {
    $output .= t('Nightly development snapshot from %tag', array('%tag' => check_plain($release->tag))) . '<br />';
  }
  if ($release->file_path) {
    $output .= '<small>' . t('Download: %file', array('%file' => l(basename($release->file_path), file_create_url($release->file_path)))) . '</small><br />';
    $output .= '<small>' . t('Size: %size', array('%size' => format_size(filesize(file_create_path($release->file_path))))) . '</small><br />';
    $output .= '<small>' . t('md5_file hash: %file_hash', array('%file_hash' => $release->file_hash)) . '</small><br />';
  }
  if ($release->created) {
    $output .= '<small>' . t('First released: %created', array('%created' => format_date($release->created))) . '</small><br />';
  }
  if ($release->changed  && ($release->changed != $release->created)) {
    $output .= '<small>' . t('Last updated: %changed', array('%changed' => format_date($release->changed))) . '</small><br />';
  }
  $output .= theme('links', $links);

  $release->body = '<div class="project-release">' . $output . '</div>' . check_markup($release->body, $release->format);
}

/**
 * Display a list of releases for a given project
 * @ingroup project_release_api
 */
function project_release_project_releases() {
  $node = node_load(arg(1));

  // Breadcrumb navigation
  $breadcrumb[] = array('path' => 'node/'. $node->nid .'/', 'title' => $node->title);
  $breadcrumb[] = array('path' => 'node/'. arg(1) .'/release', 'title' => t('Releases'));
  $breadcrumb = project_project_set_location($node, $breadcrumb);

  menu_set_location($breadcrumb);

  $output = project_release_list($node);

  drupal_set_title(t('Releases for %project', array('%project' => theme('placeholder', $node->title))));
  return $output;
}

/**
 * Get an array of release nodes
 * @ingroup project_release_api
 */
function project_release_get_releases($project, $nodes = true, $sort_by = 'version') {
  if ($sort_by == 'date') {
    $order_by = 'n.created';
  }
  else {
    $order_by = 'r.version';
  }
  $result = db_query(db_rewrite_sql("SELECT n.nid, r.* FROM {node} n INNER JOIN {project_release_nodes} r ON r.nid = n.nid WHERE r.pid = %d AND n.status = 1 ORDER BY $order_by DESC"), $project->nid);
  $releases = array();
  while ($obj = db_fetch_object($result)) {
    if ($nodes) {
      $releases[$obj->nid] = node_load($obj->nid);
    }
    else {
      $releases[$obj->nid] = $obj->version;
    }
  }
  return $releases;
}


/**
 * @defgroup project_release_callback Menu callback functions
 */

/**
 * Returns a listing of project release nodes
 * @ingroup project_release_callback
 */
function project_release_list($project, $main = 0) {
  if ($releases = project_release_get_releases($project, 1, 'date')) {
    foreach ($releases as $release) {
      $output .= node_view($release);
    }
  }
  else {
    $output = t('There are no published releases for this project. Recently added releases will not be published until the packaging scripts have run.');
  }
  return $output;
}

/**
 * Returns a listing of all unique version strings in the system.
 * @ingroup project_release_api
 *
 * TODO: This is potentially scary. We're not really going to want
 * exactly this behavior in the new system. We should reconsider the
 * places that call this (project_releases_settings(), the main
 * modules download page for filtering versions, and from inside the
 * directory scanning stuff, which may be removed) and figure out how
 * this should work... 
 */
function project_releases_list($refresh = FALSE) {
  if (!$refresh && ($versions = cache_get('project_releases'))) {
    $versions = unserialize($versions->data);
  }
  else {
    $result = db_query("SELECT prn.version FROM {project_release_nodes} prn INNER JOIN {node} n on n.nid = prn.nid WHERE n.status = 1 GROUP BY prn.version, n.created ORDER BY n.created DESC;");
    $versions = array();
    while ($object = db_fetch_object($result)) {
      $version = preg_replace('/^(.+?)\.?(?:\d+)?$/', '\1', $object->version);
      $versions[$version] = $version == $object->version ? $version : $version .'.x';
    }
    cache_set('project_releases', serialize($versions));
    menu_rebuild();
  }

  return $versions;
}


/**
 * @defgroup project_release_fapi Form API hooks
 */

/**
 * Implementation of hook_form_alter().
 * @ingroup project_release_fapi
 */
function project_release_form_alter($form_id, &$form) {
  if ($form_id == 'project_project_node_form') {
    return project_release_alter_project_form($form);
  }
  if ($form_id == 'project_release_node_form') {
    return project_release_alter_release_form($form);
  }
}

/**
 * Alters the project_project node form to add release settings.
 * @ingroup project_release_fapi
 * @see project_release_form_alter
 */
function project_release_alter_project_form(&$form) {
  $node = $form['#node'];
  $form['release'] = array(
    '#type' => 'fieldset',
    '#title' => t('Release information'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['release']['releases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable releases'),
    '#return_value' => 1,
    '#weight' => -10,
    '#default_value' => isset($node->releases) ? $node->releases : 1,
    '#description' => t('Allow releases of this project with specific versions.'),
  );
  if ($releases = project_release_get_releases($node, false)) {
    $form['release']['version'] = array(
      '#type' => 'select',
      '#title' => t('Default version'),
      '#default_value' => $node->version,
      '#options' => $releases,
      '#description' => t('Default version for downloading.'),
    );
  }

  // TODO: disable this form element if the "Enable releases" checkbox
  // is not checked?
  if (user_access('administer projects')) {
    $form['release']['version_format'] = array(
      '#type' => 'textfield',
      '#title' => t('Version format string'),
      '#default_value' => $node->version_format,
      '#size' => 50,
      '#maxlength' => 255,
      '#description' => t('Customize the format of the version strings for releases of this project.') .' '. t('Available variables are:') .' %api, %major, %minor, %patch, %extra. '. t("The percent sign ('%') at the front of the variable name indicates that a period ('.') should be inserted as a delimiter before the value of the variable. The '%' can be replaced with a hash mark ('#') to use a hyphen ('-') delimiter, or with an exclaimation point ('!') to have the value printed without a delimiter. Any variable in the format string that has no value will be removed entirely from the final string.") .' '. t('If blank, this project will use the site-wide default (currently set to: %default)', array('%default' => theme('placeholder', variable_get('project_release_default_version_format', PROJECT_RELEASE_DEFAULT_VERSION_FORMAT)))),
    );
  }
}

/**
 * Alters the project_release node form to handle the API taxonomy.
 * If the vocabulary is empty, this removes the form elements.
 * @ingroup project_release_fapi
 * @see project_release_form_alter
 */
function project_release_alter_release_form(&$form) {
  global $user;
  $node = $form['#node'];
  $vid = _project_release_get_api_vid();
  if (!project_release_use_taxonomy() && isset($form['taxonomy'][$vid])) {
    unset($form['taxonomy'][$vid]);
  }
  else {
    if (isset($node->pid)) {
      $project->nid = $node->pid;
      $tid = $node->version_api_tid;
    }
    elseif (arg(1) == 'add' && is_numeric(arg(3))) {
      $project->nid = arg(3);
    }
    if (isset($project->nid)) {
      $format = project_release_get_version_format($project);
      if (!preg_match('/[!#%]api/', $format)) {
        $vid = _project_release_get_api_vid();
        if (isset($form['taxonomy'][$vid])) {
          unset($form['taxonomy'][$vid]);
        }
      }
      elseif (isset($tid) && !user_access('administer projects')) {
        // We're editing a release node, the user doesn't have
        // 'administer projects' permission, and we already have the 
        // api compatibility term, so we want to force it to stay.
        $options[$tid] = $form['taxonomy'][$vid]['#options'][$tid];
        $form['taxonomy'][$vid]['#options'] = $options;
        $form['taxonomy'][$vid]['#default_value'] = $tid;
      }
    }
  }
  // If there are no children elements, we should unset the entire
  // thing so we don't end up with an empty fieldset.
  if (!element_children($form['taxonomy'])) {
    unset($form['taxonomy']);
  }
}


/**
 * @defgroup project_release_nodeapi Node API hooks
 */

/**
 * hook_nodeapi() implementation. This just decides what type of node
 * is being passed, and calls the appropriate type-specific hook.
 * @ingroup project_release_nodeapi
 * @see project_release_project_nodeapi().
 */
function project_release_nodeapi(&$node, $op, $arg) {
  switch ($node->type) {
    case 'project_project':
      project_release_project_nodeapi($node, $op, $arg);
      break;
  }
}

/**
 * hook_nodeapi implementation specific to "project_project" nodes
 * (from the project.module)
 * @ingroup project_release_nodeapi
 * @see project_release_nodeapi().
 */
function project_release_project_nodeapi(&$node, $op, $arg) {
  switch ($op) {
    case 'load':
      $project = db_fetch_object(db_query('SELECT * FROM {project_release_projects} WHERE nid = %d', $node->nid));
      foreach (array('releases', 'version_format') as $field) {
        $node->$field = $project->$field;
      }
      break;

    case 'insert':
      db_query("INSERT INTO {project_release_projects} (nid, releases, version_format) VALUES (%d, %d, '%s')", $node->nid, $node->releases, $node->version_format);
      break;

    case 'update':
      db_query("UPDATE {project_release_projects} SET releases = %d, version_format = '%s' WHERE nid = %d", $node->releases, $node->version_format, $node->nid);
      break;

    case 'delete':
      // TODO: unpublish (delete?) all release nodes associated with
      // this project, too.
      db_query('DELETE FROM {project_release_projects} WHERE nid = %d', $node->nid);

  }
}

/**
 * Returns the appropriate release download table for a project node.
 * TODO: make it work. ;)
 * TODO: this should be themeable.
 */
function project_release_project_download_table($node) {
  $links[] = l(t('Add new release'), 'node/add/project_release/'. $node->nid);
  $links[] = l(t('View all releases'), 'node/'. $node->nid .'/release');
  return theme('item_list', $links, t('Releases'));
}

/**
 * Implementation of hook_taxonomy().
 */
function project_release_taxonomy($op, $type, $object = NULL) {
  if ($op == 'delete' && $type == 'vocabulary' && $object->vid == _project_release_get_api_vid()) {
    variable_del('project_release_api_vocabulary');
  }
  elseif ($type == 'term' && $object->vid == _project_release_get_api_vid()) {
    menu_rebuild();
  }
}

/**
 * Returns whether or not project releases should use a taxonomy for 
 * API compatibility within the version string
 */
function project_release_use_taxonomy() {
  return module_exist('taxonomy') && taxonomy_get_tree(_project_release_get_api_vid());
}

/**
 * Returns the vocabulary id for project release API
 */
function _project_release_get_api_vid() {
  $vid = variable_get('project_release_api_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a project release module vocabulary exists.
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module='%s'", 'project_release'));
    if (!$vid) {
      $edit = array('name' => t('Project release API compatibility'), 'multiple' => 0, 'hierarchy' => 1, 'relations' => 0, 'module' => 'project_release', 'nodes' => array('project_release' => 1));
      // If there is already a vocabulary assigned to 'project_project' nodes, use it.
      $vocabularies = taxonomy_get_vocabularies('project_release');
      if (count($vocabularies)) {
        $vocabulary = reset($vocabularies);
        $edit['vid'] = $vocabulary->vid;
      }
      taxonomy_save_vocabulary($edit);
      $vid = $edit['vid'];
    }
    variable_set('project_release_api_vocabulary', $vid);
  }
  return $vid;
}

function project_release_exists($version) {
  $fields = array('version_major', 'version_minor', 'version_patch');
  foreach ($fields as $field) {
    if (isset($version->$field) && is_numeric($version->$field)) {
      $types[$field] = "%d";
      $values[$field] = $version->$field;
      $foo = $version->$field;
    }
  }
  $fields = array('version', 'version_extra');
  foreach ($fields as $field) {
    if (isset($version->$field) && $version->$field !== '') {
      $types[$field] = "'%s'";
      $values[$field] = $version->$field;
      $str = $version->$field;
    }
  }
  if (!isset($types)) {
    // We have nothing to query, yet...
    return false;
  }

  if (isset($version->version_api_tid)) {
    $taxo_join = ' INNER JOIN {term_node} t ON p.nid = t.nid';
    $taxo_where = ' AND t.tid = %d';
    $values['tid'] = $version->version_api_tid;
    $tid = $version->version_api_tid;
  }

  $sql = 'SELECT * FROM {project_release_nodes} p'. $taxo_join .' WHERE p.pid = %d';
  foreach ($types as $field => $type) {
    $sql .= " AND p.$field = $type";
  }
  $sql .= $taxo_where;
  // we put pid as the first WHERE, so stick it on the front
  $values = array_merge(array('pid' => $version->pid), $values);
  return db_num_rows(db_query($sql, $values));
}


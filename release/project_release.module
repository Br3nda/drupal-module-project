<?php
// $Id: project_release.module,v 1.1.2.52 2006/12/08 20:46:23 dww Exp $
// $Name:  $

define('PROJECT_RELEASE_DEFAULT_VERSION_FORMAT', '!major%minor%patch#extra');
define('PROJECT_RELEASE_VERSION_FORMAT_VALID_MSG', t("The version format string can only contain letters, numbers, and the characters . _ and - (in addition to the special characters used for identifying variables: % ! and #)."));
define('PROJECT_RELEASE_VERSION_FORMAT_HELP', t('Available variables are:') .' %api, %major, %minor, %patch, %extra. '. t("The percent sign ('%') at the front of the variable name indicates that a period ('.') should be inserted as a delimiter before the value of the variable. The '%' can be replaced with a hash mark ('#') to use a hyphen ('-') delimiter, or with an exclaimation point ('!') to have the value printed without a delimiter. Any variable in the format string that has no value will be removed entirely from the final string.") .' '. PROJECT_RELEASE_VERSION_FORMAT_VALID_MSG);

/**
 * @defgroup project_release_core Core Drupal hooks
 */

/**
 * Implementation of hook_help().
 * @ingroup project_release_core
 */
function project_release_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Provides a project release node type.');
    case 'node/add#project_release':
      return t('A release of a project with a specific version number.');
  }
}

/**
 * Implementation of hook_menu()
 * @ingroup project_release_core
 */
function project_release_menu($may_cache) {
  $items = array();
  global $user;

  if (!$may_cache) {
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      if ($node->type == 'project_project') {
        $items[] = array('path' => 'node/'. arg(1) .'/release', 'title' => t('releases'), 'callback' => 'project_release_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
        if (node_access('update', $node)) {
          $items[] = array('path' => 'node/'. arg(1) .'/release/overview', 'title' => t('overview'), 'callback' => 'project_release_project_releases', 'access' => node_access('view', $node), 'weight' => 0, 'type' => MENU_CALLBACK);
          $items[] = array(
            'path' => 'node/'. arg(1) .'/edit/releases',
            'title' => t('releases'),
            'callback' => 'project_release_project_edit_releases',
            'weight' => 0, 'type' => MENU_LOCAL_TASK,
          );
        }
      }
    }
    theme_add_style(drupal_get_path('module', 'project_release') .'/project_release.css');
    project_release_get_api_taxonomy();
  }
  return $items;
}

/**
 * Callback for the main settings page.
 * @ingroup project_release_core
 */
function project_release_settings() {
  if ($rel_dir = variable_get('project_release_directory', '')) {
    $form['project_release_directory'] = array(
      '#type' => 'textfield',
      '#title' => t('Release directory'),
      '#default_value' => $rel_dir,
      '#size' => 50,
      '#maxlength' => 255,
      '#description' => t('This setting has been temporarily deprecated. If your site depends on scanning for releases generated by an external tool, you should wait to upgrade until a future version of the project_release.module is available that restores this functionality. Set the value blank to acknowlege that you do not need this behavior, and this error will disappear.'),
    );
  }
  $form['project_release_default_version_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Default version format string'),
    '#default_value' => variable_get('project_release_default_version_format', PROJECT_RELEASE_DEFAULT_VERSION_FORMAT),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t('Customize the default format of the version strings for releases of projects on this site. Users with "administer projects" permissions can override this setting for each project.') .' '. PROJECT_RELEASE_VERSION_FORMAT_HELP,
  );

  // TODO: isn't this a dead setting, too?
  $form['project_release_unmoderate'] = array(
    '#type' => 'radios',
    '#title' => t('Unmoderate projects with releases'),
    '#default_value' => variable_get('project_release_unmoderate', 0),
    '#options' => array('Disabled', 'Enabled'),
  );

  if ($tree = project_release_get_api_taxonomy()) {
    foreach ($tree as $term) {
      $terms[$term->tid] = check_plain($term->name);
    }
    $vocab = taxonomy_get_vocabulary(_project_release_get_api_vid());
    $tids = variable_get('project_release_active_compatibility_tids', '');
    $form['project_release_active_compatibility_tids'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Active %vocab terms', array('%vocab' => check_plain($vocab->name))),
      '#default_value' => $tids,
      '#options' => $terms,
      '#description' => t('Terms from the %vocab vocabulary that should be visibile to end users and project maintainers.', array('%vocab' => theme('placeholder', $vocab->name))),
    );

    // TODO: put these 2 in a fieldset?
    $terms = array(-1 => t('all')) + $terms;
    $form['project_release_browse_versions'] = array(
      '#type' => 'checkbox',
      '#title' => t('Browse projects by release versions'),
      '#default_value' => variable_get('project_release_browse_versions', 0),
      '#description' => t('Checking this box will cause the project browsing page to have a version select.'),
    );
    $form['project_release_overview'] = array(
      '#type' => 'radios',
      '#title' => t('Default release overview'),
      '#default_value' => variable_get('project_release_overview', -1),
      '#options' => $terms,
      '#required' => TRUE,
      '#description' => t('Default release version to list on the overview page.'),
    );
    $setting_valid = array('project_release_settings_validate' => array());
    $form['#validate'] = isset($form['#validate']) ? array_merge($form['#validate'], $setting_valid) : $setting_valid;
  }
  return $form;
}

function project_release_settings_validate($form_id, $form_values, $form) {
  if (!empty($form_values['project_release_directory'])) {
    form_set_error('project_release_directory', t('Release directory setting has been deprecated.'));
  }
  $tids = $form_values['project_release_active_compatibility_tids'];
  $default_tid = $form_values['project_release_overview'];
  if ($default_tid != -1 && !$tids[$default_tid]) {
    $vocab = taxonomy_get_vocabulary(_project_release_get_api_vid());
    form_set_error('project_release_overview', t('Project release overview must be one of the active %vocab terms', array('%vocab' => check_plain($vocab->name))));
  }
  
  // Make sure the default version format has no bad characters.
  _project_release_validate_format_string($form_values, 'project_release_default_version_format');
}

/**
 * @defgroup project_release_node Drupal node-type related hooks 
 */

/**
 * Implementation of hook_access().
 * @ingroup project_release_node
 *
 * TODO: Maybe we should add new permissions for accessing release
 * nodes, but for now, we're just using the existing project perms.
 */
function project_release_access($op, $node) {
  global $user;
  switch ($op) {
    case 'view':
      return user_access('access projects') || (user_access('access own projects') && $node->uid == $user->uid);
    case 'create':
      // We only want to allow creating releases if the project is
      // specified in the URL
      if (is_numeric(arg(3))) {
        return project_check_admin_access(arg(3));
      }
      return FALSE;
    case 'update':
      return project_check_admin_access($node->pid);
    case 'delete':
      // No one should ever delete a release node, only unpublish it.
      return FALSE;
  }
}

/**
 * Implementation of hook_node_info().
 * @ingroup project_release_node
 */
function project_release_node_info() {
  return array(
    'project_release' => array('name' => t('project release'), 'base' => 'project_release'),
  );
}

/**
 * Implementation of hook_form().
 * @ingroup project_release_node
 */
function project_release_form(&$release, &$param) {
  if (arg(1) == 'add') {
    if (!is_numeric(arg(3))) {
      drupal_set_message(t('You can only add releases from a project page.'));
      drupal_not_found();
      module_invoke_all('exit');
      exit;
    }
    $release->pid = arg(3);
    $project = node_load($release->pid);
    if (!isset($project) || $project->type != 'project_project') {
      drupal_set_message(t('Node %nid is not a valid project.', array('%nid' => $release->pid)));
      drupal_not_found();
      module_invoke_all('exit');
      exit;
    }
    $form['project'] = array(
      '#type' => 'value',
      '#value' => $project,
    );
    $format = project_release_get_version_format($project);
  }
  else {
    global $user;
    $admin = user_access('administer projects');
    $is_edit = true;
    $project->nid = $release->pid;
    $format = project_release_get_version_format($project);
  }

  $form['#attributes'] = array("enctype" => "multipart/form-data");
  $form['#prefix'] = '<div class="project-release">';
  $form['#suffix'] = '</div>';

  if ($is_edit) {
    $form['rel_id'] = array(
      '#type' => 'fieldset',
      '#title' => t('Release identification'),
      '#prefix' => '<div class="version-elements">',
      '#suffix' => '</div>',
      '#weight' => -4,
      '#collapsible' => TRUE,
    );
  }
  _project_release_form_add_text_element($form['rel_id']['title'], t('Title'), $release->title, $is_edit, $admin, true, 40);
  _project_release_form_add_text_element($form['rel_id']['version'], t('Version string'), $release->version, $is_edit, $admin, true, 20);

  $form['pid'] = array(
    '#type' => 'value',
    '#value' => $release->pid,
  );
  $form['version']['num'] = array(
    '#type' => 'fieldset',
    '#title' => t('Version number elements'),
    '#collapsible' => TRUE,
    '#prefix' => '<div class="version-elements">',
    '#suffix' => '</div>',
  );
  $modify = $admin || !$is_edit;
  $form['validate_version'] = array('#type' => 'hidden', '#value' => 1);
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'major', t('Major'));
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'minor', t('Minor'));
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'patch', t('Patch-level'));
  _project_release_form_add_version_element($form, $release, $modify, $format,
    'extra', t('Extra identifier'), t('Optionally specify other identifying information for this version, for example "beta-1", "rc-1" or "dev". In most cases, this should be left blank.'), 40);

  $form['file'] = array(
    '#type' => 'fieldset',
    '#title' => t('File information'),
    '#collapsible' => TRUE,
  );
  if (empty($release->file_path)) {
    $form['file']['file'] = array(
      '#title' => t('File'),
      '#type' => 'file',
      '#description' => t('Choose the file that will be associated with this release.'),
    );
  }

  $form['body_filter'] = array(
    '#type' => 'fieldset',
    '#title' => t('Description'),
    '#collapsible' => TRUE,
  );
  $form['body_filter']['body'] = array(
    '#title' => t('Body'),
    '#type' => 'textarea',
    '#default_value' => $release->body,
    '#rows' => 10,
    '#cols' => 40,
    '#required' => $admin ? FALSE : TRUE,
    '#description' => t('Enter a description of this release, such as a list of the major changes or updates.'),
  );
  $form['body_filter']['format'] = filter_form($node->format);

  _project_release_form_add_text_element($form['tag']['tag'], t('Tag'), $release->tag, $is_edit, $admin);
  $form['tag']['rebuild'] = array(
    '#type' => 'value',
    '#value' => $release->rebuild,
  );
  _project_release_form_add_text_element($form['file']['file_path'], t('File path'), $release->file_path, $is_edit, $admin, false);
  _project_release_form_add_text_element($form['file']['file_hash'], t('File md5 hash'), $release->file_hash, $is_edit, false);
  _project_release_form_add_text_element($form['file']['file_date'], t('File date'), $release->file_date, $is_edit, false);

  return $form;
}

/**
 * @defgroup project_release_internal Internal module functions
 */

/**
 * Modifies the given $form array to add the appropriate form element
 * for the requested version field. Since the 20+ lines of code in
 * here have to be duplicated 6 times in project_release_form(), this
 * function exists so we can reuse the code.
 * @see project_release_form
 * @ingroup project_release_internal
 *
 * @param $form Form array to modify
 * @param $release Relase node the form is for
 * @param $modify Boolean indicating if we should allow modifications
 * @param $format Version format string for this project
 * @param $name Name of this version element
 * @param $title Translatable title of the form element
 * @param $description Translatable description of the form element.
 * @param $required Boolean for if the form element should be required
 */
function _project_release_form_add_version_element(&$form, $release, $modify, $format, $name, $title, $description = '', $size = 10) {
  $var_name = 'version_' . $name;
  $regexp = "@.*[!#%]$name.*@";
  if (preg_match($regexp, $format)) {
    $form['version']['num'][$var_name] = array(
      '#type' => 'textfield',
      '#title' => $title,
      '#default_value' => $release->$var_name,
      '#size' => $size,
      '#maxlength' => $size+10,
      '#attributes' => array('style' => 'width:auto'),
    );
    if ($required) {
      // TODO: handle this more flexibly for sites not using CVS
      // perhaps if the format variable is UPPERCASE it's required,
      // and lowercase is optional or something crazy?
      $form[$var_name]['#required'] = TRUE;
    }
    if ($description) {
      $form['version']['num'][$var_name]['#description'] = $description;
    }
    if (!$modify) {
      $form['version']['num'][$var_name]['#attributes'] = array('disabled' => 'disabled');
    }
  }
  else {
    $form['version']['num'][$var_name] = array(
      '#type' => 'value',
      '#value' => $release->$var_name,
    );
  }
}

/**
 * Modifies the given $form array to add the appropriate form element
 * for the desired text field. Since the 16+ lines of code in here
 * have to be duplicated 5 times in project_release_form(), this
 * function exists so we can reuse the code.
 * @see project_release_form
 * @ingroup project_release_internal
 *
 * @param $form Reference to form element to add
 * @param $title Translatable title of the form element
 * @param $value The value to use in the form
 * @param $is_edit Boolean indicating if we're editing or creating
 * @param $admin Boolean for if the edit is by a project administrator
 * @param $required Boolean for if the field should be required
 */
function _project_release_form_add_text_element(&$form, $title, $value, $is_edit, $admin, $required = true, $size = 40) {
  if ($is_edit && !empty($value)) {
    $form = array(
      '#type' => 'textfield',
      '#title' => $title,
      '#default_value' => $value,
      '#required' => $required,
      '#size' => $size,
      '#maxlength' => $size+10,
    );
    if(!$admin) {
      $form['#attributes']['disabled'] = 'disabled';
    }
  }
  else {
    $form = array(
      '#type' => 'value',
      '#value' => $value,
    );
  }
}

/**
 * Implementation of hook_validate().
 * @ingroup project_release_node
 */
function project_release_validate(&$edit, $form) {
  if ($_POST['edit']['validate_version']) {
    if (!isset($edit->version_major) && !isset($edit->version_minor) &&
        !isset($edit->version_patch) &&
        (!($edit->version_extra) || $edit->version_extra === '')) {
      form_set_error('version_major', t('You must fill in some version information.'));
      // TODO: find a better form value to mark as the error?
    }
    foreach (array('version_major' => 'Major version number', 'version_minor' => 'Minor version number') as $field => $name) {
      $val = $edit->$field;
      if (isset($val) && $val !== '' && !is_numeric($val)) {
        form_set_error($field, t('%name must be a number.', array('%name' => $name)));
      }
    }
    $val = $edit->version_patch;
    if (isset($val) && $val !== '' && !is_numeric($val) && $val != 'x') {
      form_set_error('version_patch', t("Patch-level version number must be numeric or the letter 'x'."));
    }
  }

  if ($file = file_check_upload('file')) {
    $file = file_save_upload('file', file_directory_path());
    if ($file) {
      $filepath = file_create_path($file->filepath);
      form_set_value($form['file']['file_path'], $file->filepath);
      form_set_value($form['file']['file_date'], filemtime($filepath));
      form_set_value($form['file']['file_hash'], md5_file($filepath));
    }
    else {
      form_set_error('file', t('There was a problem uploading the specified file.'));
    }
  }
  if (project_release_get_api_taxonomy()) {
    $vid = _project_release_get_api_vid();
    if (isset($edit->taxonomy)) {
      $tid = $edit->taxonomy[$vid];
    }
    elseif (isset($edit->$vid)) {
      $tid = $edit->$vid;
    }
    if (isset($tid) && is_numeric($tid)) {
      $edit->version_api_tid = $tid;
    }
  }

  // With cvs.module installed, this validation is already handled.
  // We only want to do it here if we're *not* doing the N-page form...
  if (!module_exist('cvs') && !isset($edit->nid) && project_release_exists($edit)) {
    // TODO: is there a better form element to mark with this error?
    form_set_error('version_patch', t('This version already exists for this project.'));
  }

  // TODO: it'd be nice to automagically reset the version string and
  // title based on changes to the version elements on an edit, but we
  // have to be careful not to break the fancy N-page form when
  // cvs_form_alter() is involved...
  if (isset($edit->project->uri)) {
    $project_name = $edit->project->uri;
  }
  elseif (isset($edit->pid)) {
    $project_name = db_result(db_query("SELECT uri FROM {project_projects} WHERE nid = %d", $edit->pid));
  }
  if (isset($edit->title)) {
    // TODO: Magic re-setting to "%project_name %version" ??
  }
  elseif (isset($edit->version) && $edit->version !== '') {
    form_set_value($form['title'], "$project_name $edit->version");
  }
  elseif (isset($edit->project)) {
    $version = project_release_get_version((object)$edit, $edit->project);
    form_set_value(array('#parents' => array('version')), $version);
    $title = $edit->project->title;
    form_set_value($form['title'], "$title $version");
  }
}

/**
 * Implementation of hook_load().
 * @ingroup project_release_node
 */
function project_release_load($node) {
  $additions = db_fetch_object(db_query("SELECT * FROM {project_release_nodes} WHERE nid = %d", $node->nid));
  $tid = db_result(db_query("SELECT tn.tid FROM {term_node} tn INNER JOIN {term_data} td ON tn.tid = td.tid WHERE tn.nid = %d", $node->nid));
  $additions->version_api_tid = $tid;
  return $additions;
}

/**
 * Implementation of hook_insert().
 * @ingroup project_release_node
 */
function project_release_insert($node) {
  project_release_db_save($node, true);
  if (module_exist('cvs')) {
    if ($node->rebuild) {
      $msg = variable_get('cvs_message_new_release_branch', '');
    }
    else {
      $msg = variable_get('cvs_message_new_release_tag', '');
    }
    if (!empty($msg)) {
      drupal_set_message($msg);
    }
  }
}

/**
 * Implementation of hook_update().
 * @ingroup project_release_node
 */
function project_release_update($node) {
  project_release_db_save($node, false);
}

/**
 * Helper method to take data out of a $node object and store it into 
 * the DB as necessary. Sadly, db_query() doesn't let us store NULL in
 * the DB, since those get cast to 0. Therefore, we have to do some 
 * manual effort to dynamically create the appropriate SQL depending
 * on which version fields are set in the release node.
 * @see project_release_insert
 * @see project_release_update
 * @see db_query
 * @ingroup project_release_internal
 *
 * @param $node Node object to save
 * @param $is_new Is this a new release node, or are we updating?
 */
function project_release_db_save($node, $is_new) {
  // If the patch field is set to a non-numeric value, we just want to 
  // keep it as a NULL in the DB, instead of casting it to a 0.
  if (isset($node->version_patch) && !is_numeric($node->version_patch)) {
    unset($node->version_patch);
  }
  $types = array( 'pid' => "%d", 'version' => "'%s'", 'tag' => "'%s'",
    'file_path' => "'%s'", 'file_date' => "%d", 'file_hash' => "'%s'",
    'rebuild' => "%d",
  );
  $values = array( 'pid' => $node->pid, 'version' => $node->version,
    'tag' => $node->tag, 'file_path' => $node->file_path,
    'file_date' => $node->file_date, 'file_hash' => $node->file_hash,
    'rebuild' => $node->rebuild,
  );
  $fields = array('version_major', 'version_minor', 'version_patch');
  foreach ($fields as $field) {
    if (isset($node->$field) && is_numeric($node->$field)) {
      $types[$field] = "%d";
      $values[$field] = $node->$field;
    }
  }
  if (!empty($node->version_extra)) {
    $types['version_extra'] = "'%s'";
    $values['version_extra'] = $node->version_extra;
  }

  if ($is_new) {
    $types['nid'] = "%d";
    $sql = 'INSERT INTO {project_release_nodes} ('. implode(', ', array_keys($types)) .') VALUES ('. implode(', ', $types) .')';
  }
  else {
   $arr = array();
   foreach ($types as $key => $value) {
     $arr[] = $key .' = '. $value;
   }
   $sql = 'UPDATE {project_release_nodes} SET '. implode(',', $arr) .' WHERE nid = %d';
  }
  $values['nid'] = $node->nid;
  db_query($sql, $values);

  // If this is the first release for a given compatibility term, add
  // a record into the {project_release_default_versions} table.
  if ($is_new && module_exist('taxonomy')) {
    $vid = _project_release_get_api_vid();
    if (isset($node->taxonomy[$vid])) {
      $tid = $node->taxonomy[$vid];
      $has_default = db_result(db_query("SELECT COUNT(*) FROM {project_release_default_versions} WHERE nid = %d AND tid = %d", $node->pid, $tid));
      if (!$has_default) {
        db_query("INSERT INTO {project_release_default_versions} (nid, tid, major) VALUES (%d, %d, %d)", $node->pid, $tid, $node->version_major);
      }
    }
  }
}

/**
 * Implementation of hook_delete().
 * @ingroup project_release_node
 */
function project_release_delete($node) {
  if ($node->file_path) {
    file_delete(file_create_path($node->file_path));
  }
  db_query("DELETE FROM {project_release_nodes} WHERE nid = %d", $node->nid);
}


/**
 * @defgroup project_release_api Project release functions that other
 * modules might want to use
 */

/**
 * Returns the version format string for a given project
 * @ingroup project_release_api
 */
function project_release_get_version_format($project) {
  if (!empty($project->version_format)) {
    return $project->version_format;
  }

  $db_format = db_result(db_query("SELECT version_format FROM {project_release_projects} WHERE nid = %d", $project->nid));
  if (!empty($db_format)) {
    return $db_format;
  }

  return variable_get('project_release_default_version_format', PROJECT_RELEASE_DEFAULT_VERSION_FORMAT);
}

/**
 * Validates a version format string. Only alphanumeric characters and 
 * [-_.] are allowed. Calls form_set_error() on error, else returns.
 * @param $form_values Array of form values passed to validate hook.
 * @param $element The name of the form element for the format string.
 * @ingroup project_release_internal
 */
function _project_release_validate_format_string($form_values, $element) {
  if (!preg_match('/^[a-zA-Z0-9_\-.!%#]+$/', $form_values[$element])) {
    form_set_error($element, PROJECT_RELEASE_VERSION_FORMAT_VALID_MSG);
  }
}

/**
 * Returns the formatted version string for a given release node.
 * @ingroup project_release_api
 */
function project_release_get_version($release, $project = NULL) {
  if (isset($project)) {
    $node = $project;
  }
  else {
    $node->nid = $release->pid;
  }
  $variables = array();
  foreach (array('major', 'minor', 'patch', 'extra') as $field) {
    $var = "version_$field";
    if (isset($release->$var) && $release->$var !== '') {
      $variables["!$field"] = $release->$var;
      $variables["%$field"] = '.' . $release->$var;
      $variables["#$field"] = '-' . $release->$var;
    }
    else {
      $variables["!$field"] = '';
      $variables["%$field"] = '';
      $variables["#$field"] = '';
    }
  }
  $variables["!api"] = '';
  $variables["%api"] = '';
  $variables["#api"] = '';
  $vid = _project_release_get_api_vid();
  if (project_release_get_api_taxonomy()) { 
    if (isset($release->version_api_tid)) {
      $tid = $release->version_api_tid;
    }
    elseif (isset($release->$vid)) {
      $tid = $release->$vid;
    }
    if (isset($tid)) {
      $term = taxonomy_get_term($tid);
      $variables["!api"] = $term->name;
      $variables["%api"] = '.' . $term->name;
      $variables["#api"] = '-' . $term->name;
    }
  }
  $version_format = project_release_get_version_format($node);
  return strtr($version_format, $variables);
}

/**
 * Implementation of hook_view().
 * @ingroup project_release_node
 */
function project_release_view(&$release, $teaser = FALSE, $page = FALSE) {
  $project = node_load($release->pid);

  if ($page) {
    // Breadcrumb navigation
    $breadcrumb[] = l($project->title, 'node/'. $project->nid);
    $breadcrumb[] = l(t('Releases'), 'node/'. $project->nid . '/release');
    project_project_set_breadcrumb($project, $breadcrumb);
  }

  $links = array();
  if ($release->rebuild) {
    $output .= t('Nightly development snapshot from %tag', array('%tag' => check_plain($release->tag))) . '<br />';
  }
  if ($release->file_path) {
    $output .= '<small>' . t('Download: %file', array('%file' => l(basename($release->file_path), file_create_url($release->file_path)))) . '</small><br />';
    $output .= '<small>' . t('Size: %size', array('%size' => format_size(filesize(file_create_path($release->file_path))))) . '</small><br />';
    $output .= '<small>' . t('md5_file hash: %file_hash', array('%file_hash' => $release->file_hash)) . '</small><br />';
  }
  if ($release->created) {
    $output .= '<small>' . t('First released: %created', array('%created' => format_date($release->created))) . '</small><br />';
  }
  if ($release->changed  && ($release->changed != $release->created)) {
    $output .= '<small>' . t('Last updated: %changed', array('%changed' => format_date($release->file_date))) . '</small><br />';
  }
  $output .= theme('links', $links);

  $release->body = '<div class="project-release">' . $output . '</div>' . check_markup($release->body, $release->format, FALSE);
}

/**
 * Display a list of releases for a given project
 * @ingroup project_release_api
 */
function project_release_project_releases() {
  $node = node_load(arg(1));

  // Breadcrumb navigation
  $breadcrumb[] = l($node->title, 'node/'. $node->nid);
  project_project_set_breadcrumb($node, $breadcrumb);

  $output = project_release_list($node);

  drupal_set_title(t('Releases for %project', array('%project' => theme('placeholder', $node->title))));
  return $output;
}

/**
 * Get an array of release nodes
 * @ingroup project_release_api
 */
function project_release_get_releases($project, $nodes = true, $sort_by = 'version', $filter_by = 'all') {
  if ($sort_by == 'date') {
    $order_by = 'n.created';
  }
  else {
    $order_by = 'r.version';
  }
  if ($filter_by == 'files') {
    $where = "AND (r.file_path <> '')";
  }
  $result = db_query(db_rewrite_sql("SELECT n.nid, r.* FROM {node} n INNER JOIN {project_release_nodes} r ON r.nid = n.nid WHERE (r.pid = %d) AND (n.status = 1) $where ORDER BY $order_by DESC"), $project->nid);
  $releases = array();
  while ($obj = db_fetch_object($result)) {
    if ($nodes) {
      $releases[$obj->nid] = node_load($obj->nid);
    }
    else {
      $releases[$obj->nid] = $obj->version;
    }
  }
  return $releases;
}


/**
 * @defgroup project_release_callback Menu callback functions
 */

/**
 * Returns a listing of project release nodes
 * @ingroup project_release_callback
 */
function project_release_list($project, $main = 0) {
  if ($releases = project_release_get_releases($project, 1, 'date', 'files')) {
    foreach ($releases as $release) {
      $output .= node_view($release);
    }
  }
  else {
    $output = t('There are no published releases for this project. Recently added releases will not be published until the packaging scripts have run.');
  }
  return $output;
}

/**
 * Returns a listing of all active project release compatibility terms
 * in the system.
 * @ingroup project_release_api
 */
function project_release_compatibility_list() {
  if ($tree = project_release_get_api_taxonomy()) {
    $tids = variable_get('project_release_active_compatibility_tids', '');
    $terms[-1] = '<' . t('all') . '>';
    foreach ($tree as $term) {
      if (($tids && !empty($tids[$term->tid])) || !$tids) {
        $terms[$term->tid] = $term->name;
      }
    }
  }
  return $terms;
}

/**
 * Creates a form array for the "filter by version" selector when browsing
 * projects on a site with 'project_release_browse_versions' enabled.
 * @see project_page_overview
 */
function project_release_version_filter_form($version) {
  if ($terms = project_release_compatibility_list()) {
    $form['version_tid'] = array(
      '#type' => 'select',
      '#default_value' => $version,
      '#options' => $terms,
    );
    $form['submit'] = array(
      '#type' => 'button',
      '#value' => t('Go')
    );
  }
  return $form;
}

function theme_project_release_version_filter_form($form) {
  if (project_release_get_api_taxonomy()) {
    $vocab = taxonomy_get_vocabulary(_project_release_get_api_vid());
    $label = check_plain($vocab->name);
  }
  else {
    $label = t('version');
  }
  $output = '<div class="container-inline">' . t('Filter by %label:', array('%label' => $label)) . form_render($form) . '</div>';
  return $output;
}


/**
 * @defgroup project_release_fapi Form API hooks
 */

/**
 * Implementation of hook_form_alter().
 * @ingroup project_release_fapi
 */
function project_release_form_alter($form_id, &$form) {
  if ($form_id == 'project_project_node_form') {
    return project_release_alter_project_form($form);
  }
  if ($form_id == 'project_release_node_form') {
    return project_release_alter_release_form($form);
  }
}

/**
 * Alters the project_project node form to add release settings.
 * @ingroup project_release_fapi
 * @see project_release_form_alter
 */
function project_release_alter_project_form(&$form) {
  $form['project']['uri']['#description'] .= ' '. t("This string is also used to generate the name of releases associated with this project.");
}

/**
 * Releases subtab for the project edit tab.
 */
function project_release_project_edit_releases() {
  $node = node_load(arg(1));
  project_project_set_breadcrumb($node);
  drupal_set_title(check_plain($node->title));

  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 5,
  );

  $form['advanced']['releases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable releases'),
    '#return_value' => 1,
    '#weight' => -10,
    '#default_value' => isset($node->releases) ? $node->releases : 1,
    '#description' => t('Allow releases of this project with specific versions.'),
  );
  if ($node->releases) {
    $releases = array();
    if ($tree = project_release_get_api_taxonomy()) {
      $query = db_query('SELECT tid, major FROM {project_release_default_versions} WHERE nid = %d', $node->nid);
      $node->default_versions = array();
      while ($version = db_fetch_object($query)) {
        $tid = $version->tid;
        $major = $version->major;
        $node->default_versions[$tid] = $major;
      }
      $result = db_query(db_rewrite_sql("SELECT n.nid, tn.tid, td.name, r.* FROM {node} n INNER JOIN {project_release_nodes} r ON r.nid = n.nid INNER JOIN {term_node} tn ON tn.nid = r.nid INNER JOIN {term_data} td ON tn.tid = td.tid WHERE (r.pid = %d) AND (n.status = 1) AND (r.file_path <> '') ORDER BY tn.tid, r.rebuild, r.version_major DESC, r.version_minor DESC, r.version_patch DESC, r.file_date DESC"), $node->nid);
      while ($rel = db_fetch_object($result)) {
        $tid = $rel->tid;
        $major = $rel->version_major;
        if (isset($major)) {
          $releases[$tid]['majors'][$major] = $major;
        }
        $releases[$tid]['name'] = $rel->name;
        if (!isset($releases[$tid]['current']) && (empty($node->default_versions[$tid]) || $node->default_versions[$tid] == $major)) {
          $releases[$tid]['current'] = $rel->version;
        }
      }
      $form['default_versions'] = array('#tree' => TRUE);
      foreach ($tree as $term) {
        $tid = $term->tid;
        if (isset($releases[$tid])) {
          $form['default_versions'][$tid] = array();
          if (count($releases[$tid]['majors']) > 1) {
            $form['default_versions'][$tid]['major'] = array(
              '#title' => t('Major version'),
              '#type' => 'select',
              '#options' => $releases[$tid]['majors'],
              '#default_value' => isset($node->default_versions[$tid]) ? $node->default_versions[$tid] : 1,
            );
          }
          else {
            $form['default_versions'][$tid]['major'] = array(
              '#type' => 'value',
              '#theme' => 'project_release_form_value',
              '#value' => is_array($releases[$tid]['majors']) ? current($releases[$tid]['majors']) : '',
            );
          }
          $form['default_versions'][$tid]['current_release'] = array(
            '#type' => 'value',
            '#theme' => 'project_release_form_value',
            '#value' => $releases[$tid]['current'],
          );
          $form['default_versions'][$tid]['name'] = array(
            '#type' => 'value',
            '#theme' => 'project_release_form_value',
            '#value' => $releases[$tid]['name'],
          );
        }
      }
    }

    if (user_access('administer projects')) {
      $form['advanced']['version_format'] = array(
        '#type' => 'textfield',
        '#title' => t('Version format string'),
        '#default_value' => $node->version_format,
        '#size' => 50,
        '#maxlength' => 255,
        '#description' => t('Customize the format of the version strings for releases of this project.') .' '. PROJECT_RELEASE_VERSION_FORMAT_HELP .' '. t('If blank, this project will use the site-wide default (currently set to: %default)', array('%default' => theme('placeholder', variable_get('project_release_default_version_format', PROJECT_RELEASE_DEFAULT_VERSION_FORMAT)))),
      );
      $form['#validate'] = array_merge($form['#validate'], array('project_release_project_edit_form_validate' => array()));
    }
    $vocab = taxonomy_get_vocabulary(_project_release_get_api_vid());
    $vocab = isset($vocab) ? theme('placeholder', $vocab->name) : t('version');
    $form['snapshot_table'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display snapshot releases on project page'),
      '#return_value' => 1,
      '#default_value' => isset($node->snapshot_table) ? $node->snapshot_table : 1,
      '#description' => t('Note: Even if the current default release for a given %vocabulary_name is a development snapshot, it will only be show if this checkbox is enabled.', array('%vocabulary_name' => $vocab)),
    );
  }

  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
    '#weight' => 45,
  );

  return drupal_get_form('project_release_project_edit_form', $form);
}

function theme_project_release_form_value($element) {
  return check_plain($element['#value']);
}

function theme_project_release_project_edit_form($form) {
  $output = '';
  $rows = array();
  if ($vocab = taxonomy_get_vocabulary(_project_release_get_api_vid())) {
    $header = array(
      check_plain($vocab->name),
      t('Major version'),
      t('Current default release'),
    );
  }
  foreach (element_children($form['default_versions']) as $tid) {
    $row = array();
    $row[] = form_render($form['default_versions'][$tid]['name']);
    unset($form['default_versions'][$tid]['major']['#title']);
    $row[] = form_render($form['default_versions'][$tid]['major']);
    $row[] = form_render($form['default_versions'][$tid]['current_release']);
    $rows[] = $row;
  }
  if (count($rows)) {
    $output .= '<h3>'. t('Default versions') .'</h3>';
    $output .= theme('table', $header, $rows);
    $output .= '<div class="form-item"><div class="description">'. t('This table allows you to specify the default version to download for any given %vocabulary_name. If there are releases from more than one major version number, you can select which major version should be used. For each %vocabulary_name, the current default release based on the saved major version is shown. If no official releases have been made, the development snapshot from the corresponding branch will be listed. Otherwise, the most recent official release is used.', array('%vocabulary_name' => theme('placeholder', $vocab->name))) ."</div></div>\n";
  }
  $output .= form_render($form['snapshot_table']);
  $output .= form_render($form['advanced']);
  $output .= form_render($form);
  return $output;
}

/**
 * Validates the project form regarding release-specific fields.
 * Ensures that the version format string doesn't contain bad characters.
 * @ingroup project_release_fapi
 * @see project_release_project_edit_releases
 */
function project_release_project_edit_form_validate($form_id, $form_values, $form) {
  if (!empty($form_values['version_format'])) {
    _project_release_validate_format_string($form_values, 'version_format');
  }
}

/**
 * Submit handler when project admins use the releases subtab.
 * @ingroup project_release_fapi
 * @see project_release_project_edit_releases
 */
function project_release_project_edit_form_submit($form_id, $form_values) {
  db_query("UPDATE {project_release_projects} SET releases = %d, snapshot_table = %d, version_format = '%s' WHERE nid = %d", $form_values['releases'], $form_values['snapshot_table'], $form_values['version_format'], $form_values['nid']);

  if (!empty($form_values['default_versions'])) {
    foreach ($form_values['default_versions'] as $tid => $values) {
      if ($obj = db_fetch_object(db_query("SELECT * FROM {project_release_default_versions} WHERE nid = %d AND tid = %d", $form_values['nid'], $tid))) {
        if ($obj->major != $values['major']) {
          db_query("UPDATE {project_release_default_versions} SET major = %d WHERE nid = %d AND tid = %d", $values['major'], $form_values['nid'], $tid);
        }
      }
      else {
        db_query("INSERT INTO {project_release_default_versions} (nid, tid, major) VALUES (%d, %d, %d)", $form_values['nid'], $tid, $values['major']);
      }
    }
  }
}

/**
 * Alters the project_release node form to handle the API taxonomy.
 * If the vocabulary is empty, this removes the form elements.
 * @ingroup project_release_fapi
 * @see project_release_form_alter
 */
function project_release_alter_release_form(&$form) {
  global $user;
  $node = $form['#node'];
  $vid = _project_release_get_api_vid();
  if (!project_release_get_api_taxonomy() && isset($form['taxonomy'][$vid])) {
    unset($form['taxonomy'][$vid]);
  }
  else {
/*
    if (isset($node->pid)) {
      $project->nid = $node->pid;
      $tid = $node->version_api_tid;
    }
    elseif (arg(1) == 'add' && is_numeric(arg(3))) {
      $project->nid = arg(3);
    }
    if (isset($project->nid)) {
*/
      if (!user_access('administer projects')) {
        // The user doesn't have 'administer projects' permission, so
        // we restrict their options for the compatibility taxonomy.
        if (isset($tid)) { 
          // If we already have the term, we want to force it to stay.
          $options[$tid] = $form['taxonomy'][$vid]['#options'][$tid];
          $form['taxonomy'][$vid]['#default_value'] = $tid;
        }
        elseif ($tids = variable_get('project_release_active_compatibility_tids', '')) {
          // We don't have the term since we're adding a new release.
          // Restrict to the active terms (if any).
          foreach ($form['taxonomy'][$vid]['#options'] as $tid => $name) {
             if ($tid && $tids[$tid]) {
              $options[$tid] = check_plain($name);
            }
          }
          if (!empty($options)) {
            $options = array(0 => $form['taxonomy'][$vid]['#options'][0]) + $options;
          }
        }
        if (!empty($options)) {
          $form['taxonomy'][$vid]['#options'] = $options;
        }
        else {
          unset($form['taxonomy'][$vid]);
        }
      }
//    }
  }
  // If there are no children elements, we should unset the entire
  // thing so we don't end up with an empty fieldset.
  if (!element_children($form['taxonomy'])) {
    unset($form['taxonomy']);
  }
}


/**
 * @defgroup project_release_nodeapi Node API hooks
 */

/**
 * hook_nodeapi() implementation. This just decides what type of node
 * is being passed, and calls the appropriate type-specific hook.
 * @ingroup project_release_nodeapi
 * @see project_release_project_nodeapi().
 */
function project_release_nodeapi(&$node, $op, $arg) {
  switch ($node->type) {
    case 'project_project':
      project_release_project_nodeapi($node, $op, $arg);
      break;
  }
}

/**
 * hook_nodeapi implementation specific to "project_project" nodes
 * (from the project.module)
 * @ingroup project_release_nodeapi
 * @see project_release_nodeapi().
 */
function project_release_project_nodeapi(&$node, $op, $arg) {
  switch ($op) {
    case 'load':
      $project = db_fetch_object(db_query('SELECT * FROM {project_release_projects} WHERE nid = %d', $node->nid));
      $fields = array('releases', 'version_format', 'snapshot_table');
      foreach ($fields as $field) {
        $node->$field = $project->$field;
      }
      break;

    case 'insert':
      db_query("INSERT INTO {project_release_projects} (nid, releases, snapshot_table, version_format) VALUES (%d, %d, %d, '%s')", $node->nid, 1, 1, '');
      break;

    case 'delete':
      // TODO: unpublish (delete?) all release nodes associated with
      // this project, too.
      db_query('DELETE FROM {project_release_projects} WHERE nid = %d', $node->nid);

  }
}

/**
 * Returns the appropriate release download table for a project node.
 * TODO: this should be themeable.
 */
function project_release_project_download_table($node) {
  if (!$node->releases) {
    return;
  }
  $output = '<h3>' . t('Releases') . '</h3>';
  $output .= project_release_table($node, 1, 1, FALSE, 'default-official', t('Official releases'));
  if ($node->snapshot_table) {
    $output .= project_release_table($node, 1, 3, FALSE, 'snapshot', t('Development snapshots'));
  }
  $links[] = l(t('View all releases'), 'node/'. $node->nid .'/release');
  if (project_check_admin_access($node->nid)) {
    $links[] = l(t('Add new release'), 'node/add/project_release/'. $node->nid);
  }
  $output .= theme('item_list', $links);
  return $output;
}

function project_release_table($project, $versions = 3, $releases_per_version = 3, $release_notes = FALSE, $filter = 'all', $title = NULL) {
  if (empty($title)) {
    $title = t('Version');
  }
  $select = $join = $where = $order_by = '';
  $tids = project_release_compatibility_list();
  if ($tids) {
    unset($tids[-1]); // get rid of that one.
    $join = ' INNER JOIN {term_node} tn ON n.nid = tn.nid AND tn.tid in (' 
      . implode(',', array_keys($tids)) . ') ' 
      . ' INNER JOIN {term_data} td ON td.tid = tn.tid ';
    $selects[] = 'tn.tid';
    $orderby[] = 'td.weight';
    $orderby[] = 'td.name';
  }

  if ($release_notes) {
    $join .= ' INNER JOIN {node_revisions} nr ON nr.vid = n.vid ';
    $selects[] = 'nr.body, nr.format';
  }

  if ($tids) {
    $default_join = ' INNER JOIN {project_release_default_versions} prdv ON prdv.nid = r.pid AND prdv.tid = tn.tid AND prdv.major = r.version_major ';
  }
  else {
    // TODO
    $default_join = '';
  }
  switch ($filter) {
    case 'default-official':
      $join .= $default_join;
      $where = 'AND r.rebuild <> 1';
      break;
    case 'default-all':
      $join .= $default_join;
      // Make sure snapshots come first so we only show official
      // releases (if any) when limiting the # of rows in the table.
      $orderby[] = 'r.rebuild DESC';
      break;
    case 'official':
      $where = 'AND r.rebuild <> 1';
      break;
    case 'snapshot':
      $where = 'AND r.rebuild = 1';
      break;
    default:
      $orderby[] = 'r.rebuild'; // make sure dev versions come last
      break;
  }
  $orderby[] = 'r.version_major';
  $orderby[] = 'r.version_minor';
  $orderby[] = 'r.version_patch';
  $orderby[] = 'r.file_date';

  if ($orderby) {
    $order_by = ' ORDER BY ' . implode(', ', $orderby);
  }
  if ($selects) {
    $select = implode(', ', $selects) . ',';
  }
  $result = db_query(db_rewrite_sql(
    "SELECT n.nid, $select r.* FROM {node} n " .
    "INNER JOIN {project_release_nodes} r ON r.nid = n.nid " . $join . 
    "WHERE (r.pid = %d) AND (n.status = 1) " . $where . ' ' . $order_by),
    $project->nid);

  $items = array();
  $can_edit = node_access('update', $project);

  while ($release = db_fetch_object($result)) {
    $links = array(
      l(t('Download'), file_create_url($release->file_path)),
      l(t('Release notes'), "node/$release->nid"),
    );

    if ($can_edit) {
      $links[] = l(t('Edit'), "node/$release->nid/edit");
    }
    if (!is_array($items[$release->tid])) {
      $items[$release->tid] = array();
    }
    $items[$release->tid][] = array(
      // class of <tr>
      'class' => $release->rebuild ? 'release-dev' : 'release',
      'data' => array(
        array(
          'class' => 'release-title',
          'data' => l($release->version, "node/$release->nid"),
        ),
        array(
          'class' => 'release-date',
          'data' => format_date($release->file_date, 'custom', 'Y-M-d'),
        ),
        array(
          'class' => 'release-size',
          'data' => format_size(filesize(file_create_path($release->file_path))),
        ),
        array(
          'class' => 'release-links',
          'data' => theme('links', $links),
        ),
      ),
    );
    if ($release_notes) {
      $items[$release->tid][] = array(
        'colspan' => 4,
        'class' => 'release-notes',
        'data' => check_markup($release->body, $release->format, FALSE),
      );
    }
  }
  $header = array(
    array(
      'class' => 'release-title',
      'data' => $title),
    array(
      'class' => 'release-date',
      'data' => t('Date'),
    ),
    array(
      'class' => 'release-size',
      'data' => t('Size'),
    ),
    array(
      'class' => 'release-links',
      'data' => t('Links'),
    ),
  );

  foreach ($items as $tid => $item) {
    if ($releases_per_version) {
      $hide_num = count($item) - $releases_per_version;
      for ($i = 0; $i < $hide_num; $i++) {
        array_shift($item); // pop off items we're not going to see.
      }
    }
    $rows = array_merge($rows, $item);
  }
  $output = '';
  if (!empty($rows)) {
    $output = theme('table', $header, $rows, array('class' => 'releases'));
  }
  return $output;
}

/**
 * Implementation of hook_taxonomy().
 */
function project_release_taxonomy($op, $type, $object = NULL) {
  if ($op == 'delete' && $type == 'vocabulary' && $object->vid == _project_release_get_api_vid()) {
    variable_del('project_release_api_vocabulary');
  }
  elseif ($type == 'term' && $object->vid == _project_release_get_api_vid()) {
    menu_rebuild();
  }
}

/**
 * If taxonomy is enabled, returns the taxonomy tree for the 
 * API compatibility vocabulary, otherwise, it returns false.
 */
function project_release_get_api_taxonomy() {
  if (!module_exist('taxonomy')) {
    return false;
  }
  return taxonomy_get_tree(_project_release_get_api_vid());
}

/**
 * Returns the vocabulary id for project release API
 */
function _project_release_get_api_vid() {
  $vid = variable_get('project_release_api_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a project release module vocabulary exists.
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module='%s'", 'project_release'));
    if (!$vid) {
      $edit = array('name' => t('Project release API compatibility'), 'multiple' => 0, 'hierarchy' => 1, 'relations' => 0, 'module' => 'project_release', 'nodes' => array('project_release' => 1));
      // If there is already a vocabulary assigned to 'project_project' nodes, use it.
      $vocabularies = taxonomy_get_vocabularies('project_release');
      if (count($vocabularies)) {
        $vocabulary = reset($vocabularies);
        $edit['vid'] = $vocabulary->vid;
      }
      taxonomy_save_vocabulary($edit);
      $vid = $edit['vid'];
    }
    variable_set('project_release_api_vocabulary', $vid);
  }
  return $vid;
}

function project_release_exists($version) {
  $fields = array('version_major', 'version_minor', 'version_patch');
  foreach ($fields as $field) {
    if (isset($version->$field) && is_numeric($version->$field)) {
      $types[$field] = "%d";
      $values[$field] = $version->$field;
      $foo = $version->$field;
    }
  }
  $fields = array('version', 'version_extra');
  foreach ($fields as $field) {
    if (isset($version->$field) && $version->$field !== '') {
      $types[$field] = "'%s'";
      $values[$field] = $version->$field;
      $str = $version->$field;
    }
  }
  if (!isset($types)) {
    // We have nothing to query, yet...
    return false;
  }

  if (isset($version->version_api_tid)) {
    $taxo_join = ' INNER JOIN {term_node} t ON p.nid = t.nid';
    $taxo_where = ' AND t.tid = %d';
    $values['tid'] = $version->version_api_tid;
    $tid = $version->version_api_tid;
  }

  $sql = 'SELECT * FROM {project_release_nodes} p'. $taxo_join .' WHERE p.pid = %d';
  foreach ($types as $field => $type) {
    $sql .= " AND p.$field = $type";
  }
  $sql .= $taxo_where;
  // we put pid as the first WHERE, so stick it on the front
  $values = array_merge(array('pid' => $version->pid), $values);
  return db_num_rows(db_query($sql, $values));
}

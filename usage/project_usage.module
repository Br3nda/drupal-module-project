<?php
// $Id: project_usage.module,v 1.6.2.5 2008/10/25 19:16:46 dww Exp $
// $Name:  $

/**
 * @file
 *
 * This module provides logging of the requests sent by the
 * update_status.module (contrib in 5.x) and update.module (core in 6.x) to the
 * project_release.module on updates.drupal.org. The
 * release/project-release-serve-history.php script inserts data into the
 * {project_usage_raw} table created by this module.
 *
 * On a daily basis the usage data is matched to project and release nodes
 * and moved into the {project_usage_day} table. On a weekly basis the daily
 * usage data is tallied and stored in the {project_usage_week} table.
 *
 * This data is then used to compute live usage statistics about all projects
 * hosted on drupal.org. In theory, another site could setup
 * update_status.module-style checking to their own project.module-based
 * server, in which case, they might want to enable this module. Otherwise,
 * sites should just leave this disabled.
 */

// Number of seconds in a day.
define('PROJECT_USAGE_DAY', 60 * 60 * 24);
// Number of seconds in a week.
define('PROJECT_USAGE_WEEK', PROJECT_USAGE_DAY * 7);
// Number of seconds in a year.
define('PROJECT_USAGE_YEAR', PROJECT_USAGE_DAY * 365);

/**
 * Date formats for month and day. We define our own rather than using core's
 * 'date_format_short' and 'date_format_long' variables because our timestamps
 * don't have hour or minute resolution so displaying that would be confusing
 * and take up extra space.
 */
define('PROJECT_USAGE_DATE_LONG', 'F jS');
define('PROJECT_USAGE_DATE_SHORT','M j');

// How many weeks should be shown in the usage pages?
define('PROJECT_USAGE_SHOW_WEEKS', 6);

/**
 * Implementation of hook_menu().
 */
function project_usage_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/project/project-usage-settings',
      'title' => t('Project usage settings'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('project_usage_settings_form'),
      'description' => t('Configure how long usage data is retained.'),
      'weight' => 1,
    );
    $items[] = array(
      'path' => 'project/usage',
      'title' => t('Project usage'),
      'callback' => 'project_usage_dispatch',
      'access' => user_access('view project usage'),
    );
  }
  return $items;
}

/**
 * Implementation of hook_help().
 */
function project_usage_help($section) {
  switch ($section) {
    case 'project/usage':
      return t('The following is a summary of the usage information for the projects on this site. The count is the total number of sites using any version of the project. Only sites that have opted to allow usage information to be tracked are included.');
  }
}

/**
 * Implementation of hook_perm().
 */
function project_usage_perm() {
  return array(
    'view project usage',
  );
}

/**
 * Menu handler for project URLs.
 *
 * @param $key
 *   Optional node id or project uri. NULL gets the overview page, project
 *   nids and uris get the project usage page, release nids get the release
 *   usage page, and everything else gets a not found. In addition, if a user
 *   does not have permission to view the project or release node they've
 *   requested, they get an access denied page.
 */
function project_usage_dispatch($key = NULL) {
  if (!isset($key)) {
    return project_usage_overview();
  }

  // Load the node the user has requested.  We want to only use
  // project_project_retrieve() if the $key parameter is not numeric because
  // project_project_retrieve() will only return a project_project node, and
  // we want to allow $node to also be a project_release node.
  if (is_numeric($key)) {
    $node = node_load($key);
  }
  else {
    $node = project_project_retrieve($key);
  }

  if (!empty($node->nid)) {
    // Make sure that the user has the permission to view this project/
    // project_release node.
    if (node_access('view', $node)) {
      if ($node->type == 'project_project') {
        return project_usage_project_page($node);
      }
      if ($node->type == 'project_release') {
        return project_usage_release_page($node);
      }
    }
    else {
      return drupal_access_denied();
    }
  }
  return drupal_not_found();
}

/**
 * Display an overview of usage for all modules.
 */
function project_usage_overview() {
  drupal_add_css(drupal_get_path('module', 'project_usage') .'/project_usage.css');
  drupal_set_title(t('Project usage overview'));

  $week_count = PROJECT_USAGE_SHOW_WEEKS;

  // In order to get the project usage data into a sortable table, we've gotta
  // write a pretty evil query:
  //
  // - We need to create a separate column for each week to allow sorting by
  //   usage in any week (the tablesort_sql() requires that anything you can
  //   sort on has a distinct field in the underlying query). However, some
  //   weeks may not have any usage data, forcing us to use a LEFT JOIN,
  //   rather than the more efficient INNER JOIN.
  // - The LEFT JOINs mean we have to limit the entries in {node} so that
  //   we're not including things like forum posts, hence the WHERE IN below.
  // - Each project may have multiple records in {project_usage_week_project}
  //   to track usage for API version. We need to SUM() them to get a total
  //   count forcing us to GROUP BY. Sadly, I can't explain why we need
  //   SUM(DISTINCT)... it just works(TM).
  $sql_elements = project_empty_query();
  // Ignore the order_bys generated by project_empty_query(), and use
  // the tablesort instead.
  unset($sql_elements['order_bys']);

  $where_args = array();
  $sql_elements['fields']['pieces'] = array('n.nid', 'n.title', 'pp.uri');
  $sql_elements['from']['pieces'][] = '{node} n ';
  $sql_elements['joins']['pieces'][] = "INNER JOIN {project_projects} pp ON n.nid = pp.nid";
  $sql_elements['wheres']['pieces'] = array('n.nid IN (SELECT nid FROM {project_usage_week_project}) AND n.status = %d');
  $where_args[] = 1;  // n.status = 1
  $sql_elements['group_bys']['pieces'] = array('n.nid', 'n.title');
  $headers = array(array('field' => 'n.title', 'data' => t('Project')));

  $joins_args = array();
  foreach (project_usage_get_last_weeks($week_count) as $i => $week) {
    // Note that "{$i}" in these query snippets are used to add a week integer
    // to the table and field aliases so we can uniquely identify each column
    // for sorting purposes.  These are not literals in the query, we need
    // these aliases to be unique via this PHP string operation before we even
    // build the query.
    $sql_elements['fields']['pieces'][] = "SUM(DISTINCT p{$i}.count) AS week{$i}";
    $sql_elements['joins']['pieces'][] = "LEFT JOIN {project_usage_week_project} p{$i} ON n.nid = p{$i}.nid AND p{$i}.timestamp = %d";
    $joins_args[] = $week;

    $header = array(
      'field' => "week{$i}",
      'data' => format_date($week, 'custom', variable_get('project_usage_date_short', PROJECT_USAGE_DATE_SHORT), 0),
      'class' => 'project-usage-numbers'
    );
    if ($i == 0) {
      $header['sort'] = 'desc';
    }
    $headers[] = $header;
  }

  // Check for a cached page. The cache id needs to take into account the sort
  // column and order.
  $sort = tablesort_init($headers);
  $cid = 'overview:'. $sort['sql'] .':'. $sort['sort'];
  if (project_can_cache() && $cached = cache_get($cid, 'cache_project_usage')) {
    return $cached->data;
  }

  $args = array_merge($joins_args, $where_args);
  $result = db_query(project_build_query($sql_elements) . tablesort_sql($headers), $args);

  while ($line = db_fetch_array($result)) {
    $row = array(array('data' => l($line['title'], 'project/usage/'. $line['uri'])));
    for ($i = 0; $i < $week_count; $i++) {
      $row[] = array('data' => number_format($line["week{$i}"]), 'class' => 'project-usage-numbers');
    }
    $rows[] = $row;
  }
  $output = theme('table', $headers, $rows);

  // Cache the completed page.
  if (project_can_cache()) {
    cache_set($cid, 'cache_project_usage', $output, project_usage_cache_time());
  }

  return $output;
}

/**
 * Display the usage history of a project node.
 */
function project_usage_project_page($node) {
  drupal_add_css(drupal_get_path('module', 'project_usage') .'/project_usage.css');
  $breadcrumb = array(
    l(t('Usage'), 'project/usage'),
  );
  project_project_set_breadcrumb(NULL, $breadcrumb);
  drupal_set_title(t('Usage statistics for %project', array('%project' => $node->title)));

  // In order to keep the database load down we need to cache these pages.
  // Because the release usage table is sortable, the cache id needs to take
  // into account the sort parameters. The easiest way to ensure we have valid
  // sorting parameters is to build the table headers and let the tablesort
  // functions do it. This means we end up doing most of the work to build the
  // page's second table early on. We might as well finish the job, then build
  // the other table and output them in the correct order.

  $week_count = PROJECT_USAGE_SHOW_WEEKS;
  $releases = project_release_get_releases($node, FALSE);

  // If there are no releases for this project, we can skip the rest
  // of this function.
  if (empty($releases)) {
    return theme('project_usage_project_page', $node);
  }

  // Build a table showing this week's usage for each release. In order to get
  // the release usage data into a sortable table, we need another evil query:
  // - We need to create a separate column for each week to allow sorting by
  //   usage in any week (the tablesort_sql() requires that anything you can
  //   sort on has a distinct field in the underlying query). However, some
  //   weeks may not have any usage data, forcing us to use a LEFT JOIN,
  //   rather than the more efficient INNER JOIN.
  // - We need to create a column for each week but some weeks may not have any
  //   usage data, forcing us to use a LEFT JOIN, rather than the more
  //   efficient INNER JOIN.
  // - The LEFT JOINs mean we have to limit the entries in {node} so that we're
  //   not including things like forum posts, hence the WHERE IN below.
  $sql_elements = project_empty_query();
  // Ignore the order_bys generated by project_empty_query(), and use
  // the tablesort instead.
  unset($sql_elements['order_bys']);

  $sql_elements['fields']['pieces'] = array('n.nid');
  $sql_elements['from']['pieces'][] = '{node} n ';
  $sql_elements['wheres']['pieces'] = array('n.nid IN ('. implode(', ', array_fill(0, count($releases), '%d')) .') AND n.status = %d');
  $where_args = array_keys($releases);
  $where_args[] = 1;  // n.status = 1

  $release_header = array(array('field' => 'n.title', 'data' => t('Release'), 'sort' => 'desc'));

  $joins_args = array();
  foreach (project_usage_get_last_weeks($week_count) as $i => $week) {
    // Note that "{$i}" in these query snippets are used to add a week integer
    // to the table and field aliases so we can uniquely identify each column
    // for sorting purposes.  These are not literals in the query, we need
    // these aliases to be unique via this PHP string operation before we even
    // build the query.
    $sql_elements['fields']['pieces'][] = "p{$i}.count AS week{$i}";
    $sql_elements['joins']['pieces'][] = "LEFT JOIN {project_usage_week_release} p{$i} ON n.nid = p{$i}.nid AND p{$i}.timestamp = %d";
    $joins_args[] = $week;

    $release_header[] = array(
      'field' => "week{$i}",
      'data' => format_date($week, 'custom', variable_get('project_usage_date_short', PROJECT_USAGE_DATE_SHORT), 0),
      'class' => 'project-usage-numbers',
    );
  }

  // Check for a cached page. The cache id needs to take into account the sort
  // column and order.
  $sort = tablesort_init($release_header);
  $cid = 'project:'. $node->nid .':'. $sort['sql'] .':'. $sort['sort'];
  if ($cached = cache_get($cid, 'cache_project_usage')) {
    return $cached->data;
  }

  $args = array_merge($joins_args, $where_args);
  $result = db_query(project_build_query($sql_elements) . tablesort_sql($release_header), $args);

  $release_rows = array();
  while ($line = db_fetch_array($result)) {
    $row = array(array('data' => l($releases[$line['nid']], 'project/usage/'. $line['nid'])));
    for ($i = 0; $i < $week_count; $i++) {
      $row[] = array('data' => number_format($line["week{$i}"]), 'class' => 'project-usage-numbers');
    }
    $release_rows[] = $row;
  }

  // Build a table of the weekly usage data with a column for each API version.
  // Get an array of the weeks going back as far as we have data...
  $oldest = db_result(db_query("SELECT MIN(puwp.timestamp) FROM {project_usage_week_project} puwp WHERE puwp.nid = %d", $node->nid));
  if ($oldest === NULL) {
    $weeks = array();
  }
  else {
    $weeks = project_usage_get_weeks_since($oldest);
    // ...ignore the current week, since we won't have usage data for that and
    // reverse the order so it's newest to oldest.
    array_pop($weeks);
    $weeks = array_reverse($weeks);
  }

  // The number of columns varies depending on how many different API versions
  // are in use. Set up the header and a blank, template row, based on the
  // number of distinct terms in use. This *could* be done with LEFT JOINs,
  // but it ends up being a more expensive query and harder to read.
  $project_header = array(0 => array('data' => t('Week')));
  $blank_row = array(0 => array('data' => ''));
  $result = db_query("SELECT DISTINCT td.tid, td.name FROM {project_usage_week_project} p INNER JOIN {term_data} td ON p.tid = td.tid WHERE p.nid = %d ORDER BY td.weight, td.name", $node->nid);
  while ($row = db_fetch_object($result)) {
    $project_header[$row->tid] = array('data' => check_plain($row->name), 'class' => 'project-usage-numbers');
    $blank_row[$row->tid] = array('data' => 0, 'class' => 'project-usage-numbers');
  }

  // Now create a blank table with a row for each week and formatted date in
  // the first column...
  $project_rows = array();
  foreach ($weeks as $week) {
    $project_rows[$week] = $blank_row;
    $project_rows[$week][0]['data'] = format_date($week, 'custom', variable_get('project_usage_date_long', PROJECT_USAGE_DATE_LONG), 0);
  }

  // ...then fill it in with our data.
  $result = db_query("SELECT timestamp, tid, count FROM {project_usage_week_project} WHERE nid = %d", $node->nid);
  while ($row = db_fetch_object($result)) {
    $project_rows[$row->timestamp][$row->tid]['data'] = number_format($row->count);
  }

  $output = theme('project_usage_project_page', $node, $release_header, $release_rows, $project_header, $project_rows);

  // Cache the completed page.
  if (project_can_cache()) {
    cache_set($cid, 'cache_project_usage', $output, project_usage_cache_time());
  }

  return $output;
}

/**
 * Display the usage history of a release node.
 */
function project_usage_release_page($node) {
  drupal_add_css(drupal_get_path('module', 'project_usage') .'/project_usage.css');
  $project = node_load($node->pid);
  $breadcrumb = array(
    l(t('Usage'), 'project/usage'),
    l($project->title, 'project/usage/'. $project->nid),
  );
  project_project_set_breadcrumb(NULL, $breadcrumb);
  drupal_set_title(t('Usage statistics for %release', array('%release' => $node->title)));

  // Check for a cached page.
  $cid = "release:{$node->nid}";
  if (project_can_cache() && $cached = cache_get($cid, 'cache_project_usage')) {
    return $cached->data;
  }

  // Table displaying the usage back through time.
  $header = array(
    array('data' => t('Week starting')),
    array('data' => t('Count'), 'class' => 'project-usage-numbers'),
  );
  $rows = array();
  $query = db_query("SELECT timestamp, count FROM {project_usage_week_release} WHERE nid = %d ORDER BY timestamp DESC", $node->nid);
  while ($row = db_fetch_object($query)) {
    $rows[] = array(
      array('data' => format_date($row->timestamp, 'custom', variable_get('project_usage_date_long', PROJECT_USAGE_DATE_LONG), 0)),
      array('data' => number_format($row->count), 'class' => 'project-usage-numbers'),
    );
  }
  $output = theme('project_usage_release_page', $project, $node, $header, $rows);

  // Cache the completed page.
  if (project_can_cache()) {
    cache_set($cid, 'cache_project_usage', $output, project_usage_cache_time());
  }

  return $output;
}

/**
 * Module settings form.
 */
function project_usage_settings_form() {
  $times = array(
     3 * PROJECT_USAGE_YEAR,
     2 * PROJECT_USAGE_YEAR,
     1 * PROJECT_USAGE_YEAR,
    26 * PROJECT_USAGE_WEEK,
    12 * PROJECT_USAGE_WEEK,
     8 * PROJECT_USAGE_WEEK,
     4 * PROJECT_USAGE_WEEK,
  );
  $age_options = drupal_map_assoc($times, 'format_interval');
  $form['project_usage_life_daily'] = array(
    '#type' => 'select',
    '#title' => t('Daily usage data lifespan'),
    '#default_value' => variable_get('project_usage_life_daily', 4 * PROJECT_USAGE_WEEK),
    '#options' => $age_options,
    '#description' => t("Discard the daily usage data after this amount of time has passed."),
  );
  $form['project_usage_life_weekly_project'] = array(
    '#type' => 'select',
    '#title' => t('Weekly project data lifespan'),
    '#default_value' => variable_get('project_usage_life_weekly_project', PROJECT_USAGE_YEAR),
    '#options' => $age_options,
    '#description' => t("Discard the weekly usage for project nodes after this amount of time has passed. "),
  );
  $form['project_usage_life_weekly_release'] = array(
    '#type' => 'select',
    '#title' => t('Weekly release data lifespan'),
    '#default_value' => variable_get('project_usage_life_weekly_release', 26 * PROJECT_USAGE_WEEK),
    '#options' => $age_options,
    '#description' => t("Discard the weekly usage for project nodes after this amount of time has passed. "),
  );
  return system_settings_form($form);
}

/**
 * Implementation of hook_cron().
 *
 * Call the daily and weekly processing tasks as needed.
 */
function project_usage_cron() {
  $now = time();

  // Figure out if it's been 24 hours since our last daily processing.
  if (variable_get('project_usage_last_daily', 0) <= ($now - PROJECT_USAGE_DAY)) {
    project_usage_process_daily();
    variable_set('project_usage_last_daily', $now);
  }

  // Figure out if it's been a week since we did weekly stats. If the weekly
  // data has never been processed go back only as far as there is daily data.
  $default = $now - variable_get('project_usage_life_daily', 4 * PROJECT_USAGE_WEEK);
  $last_weekly = variable_get('project_usage_last_weekly', $default);
  if ($last_weekly <= ($now - PROJECT_USAGE_WEEK)) {
    project_usage_process_weekly($last_weekly);
    variable_set('project_usage_last_weekly', $now);
  }

  // Wipe the cache of all expired usage pages.
  cache_clear_all(NULL, 'cache_project_usage');
}

/**
 * Process all the raw data up to the previous day.
 *
 * The primary key on the {project_usage_raw} table will prevent duplicate
 * records provided we process them once the day is complete. If we pull them
 * out too soon and the site checks in again they will be counted twice.
 */
function project_usage_process_daily() {
  // Timestamp for begining of the previous day.
  $timestamp = project_usage_daily_timestamp(NULL, 1);

  watchdog('project_usage', t('Starting to process daily usage data for @date.', array('@date' => format_date($timestamp))));

  // Assign API version term IDs.
  $terms = array();
  foreach (project_release_get_api_taxonomy() as $term) {
    $terms[$term->tid] = $term->name;
  }
  $query = db_query("SELECT DISTINCT api_version FROM {project_usage_raw} WHERE tid = 0");
  while ($row = db_fetch_object($query)) {
    $tid = array_search($row->api_version, $terms);
    db_query("UPDATE {project_usage_raw} SET tid = %d WHERE api_version = '%s'", $tid, $row->api_version);
  }
  watchdog('project_usage', t('Assigned API version term IDs.'));

  // Asign project and release node IDs.
  $query = db_query("SELECT DISTINCT project_uri, project_version FROM {project_usage_raw} WHERE pid = 0 OR nid = 0");
  while ($row = db_fetch_object($query)) {
    $pid = db_result(db_query("SELECT pp.nid AS pid FROM {project_projects} pp WHERE pp.uri = '%s'", $row->project_uri));
    if ($pid) {
      $nid = db_result(db_query("SELECT prn.nid FROM {project_release_nodes} prn WHERE prn.pid = %d AND prn.version = '%s'", $pid, $row->project_version));
      db_query("UPDATE {project_usage_raw} SET pid = %d, nid = %d WHERE project_uri = '%s' AND project_version = '%s'", $pid, $nid, $row->project_uri, $row->project_version);
    }
  }
  watchdog('project_usage', t('Assigned project and release node IDs.'));

  // Move usage records with project node IDs into the daily table and remove
  // the rest.
  db_query("INSERT INTO {project_usage_day} (timestamp, site_key, pid, nid, tid, ip_addr) SELECT timestamp, site_key, pid, nid, tid, ip_addr FROM {project_usage_raw} WHERE timestamp < %d AND pid <> 0", $timestamp);
  db_query("DELETE FROM {project_usage_raw} WHERE timestamp < %d", $timestamp);
  watchdog('project_usage', t('Moved usage from raw to daily.'));

  // Remove old daily records.
  $seconds = variable_get('project_usage_life_daily', 4 * PROJECT_USAGE_WEEK);
  db_query("DELETE FROM {project_usage_day} WHERE timestamp < %d", time() - $seconds);
  watchdog('project_usage', t('Removed old daily rows.'));

  watchdog('project_usage', t('Completed daily usage data processing.'));
}

/**
 * Compute the weekly summaries for the week starting at the given timestamp.
 *
 * @param $timestamp
 *   UNIX timestamp indicating the last time weekly stats were processed.
 */
function project_usage_process_weekly($timestamp) {
  watchdog('project_usage', t('Starting to process weekly usage data.'));

  // Get all the weeks since we last ran.
  $weeks = project_usage_get_weeks_since($timestamp);
  // Skip the last entry since it's the current, incomplete week.
  $count = count($weeks) - 1;
  for ($i = 0; $i < $count; $i++) {
    $start = $weeks[$i];
    $end = $weeks[$i + 1];

    // Remove any existing tallies then compute the tallies.
    db_query("DELETE FROM {project_usage_week_project} WHERE timestamp = %d", $start);
    db_query("INSERT INTO {project_usage_week_project} (nid, timestamp, tid, count) SELECT pid, %d, tid, COUNT(DISTINCT site_key) FROM {project_usage_day} WHERE timestamp >= %d AND timestamp < %d AND pid <> 0 GROUP BY pid, tid", $start, $start, $end);
    watchdog('project_usage', t('Computed weekly project tallies for @date.', array('@date' => format_date($start))));

    db_query("DELETE FROM {project_usage_week_release} WHERE timestamp = %d", $start);
    db_query("INSERT INTO {project_usage_week_release} (nid, timestamp, count) SELECT nid, %d, COUNT(DISTINCT site_key) FROM {project_usage_day} WHERE timestamp >= %d AND timestamp < %d AND nid <> 0 GROUP BY nid", $start, $start, $end);
    watchdog('project_usage', t('Computed weekly release tallies for @date.', array('@date' => format_date($start))));
  }

  // Remove any tallies that have aged out.
  $now = time();
  $project_life = variable_get('project_usage_life_weekly_project', PROJECT_USAGE_YEAR);
  db_query("DELETE FROM {project_usage_week_project} WHERE timestamp < %d", $now - $project_life);
  watchdog('project_usage', t('Removed old weekly project rows.'));

  $release_life = variable_get('project_usage_life_weekly_release', 26 * PROJECT_USAGE_WEEK);
  db_query("DELETE FROM {project_usage_week_release} WHERE timestamp < %d", $now - $release_life);
  watchdog('project_usage', t('Removed old weekly release rows.'));

  watchdog('project_usage', t('Completed weekly usage data processing.'));
}

/**
 * getdate() with timezone adjustment.
 *
 * PHP's getdate() is affected by the server's timezone. We need to cancel it
 * out so everything is GMT.
 *
 * @param $timestamp
 *   An optional, integer UNIX timestamp.
 * @return
 *   An array with results identical to PHP's getdate().
 */
function project_usage_gmgetdate($timestamp = NULL) {
  $timestamp = isset($timestamp) ? $timestamp : time();
  $gmt_offset = (int) date('Z', $timestamp);
  return getdate($timestamp - $gmt_offset);
}

/**
 * Compute a timestamp for the beginning of a day N days ago.
 *
 * @param $time
 *   Mixed, either a GMT timestamp or an array returned by
 *   project_usage_gmgetdate().
 * @param $days_ago
 *   An integer specifying a number of days previous. A value of 0 indicates
 *   the current day.
 *
 * @return
 *   GMT UNIX timestamp.
 */
function project_usage_daily_timestamp($time = NULL, $days_ago = 0) {
  $time_parts = is_array($time) ? $time : project_usage_gmgetdate($time);
  $day = $time_parts['mday'] - $days_ago;
  return gmmktime(0, 0, 0, $time_parts['mon'], $day, $time_parts['year']);
}

/**
 * Compute a timestamp for the beginning of a week N weeks ago.
 *
 * @param $time
 *   Mixed. Integer timestamp or an array returned by project_usage_gmgetdate().
 * @param $weeks_ago
 *   An integer specifying a number of weeks previous. A value of 0 indicates
 *   the current week.
 *
 * @return
 *   GMT UNIX timestamp.
 */
function project_usage_weekly_timestamp($time = NULL, $weeks_ago = 0) {
  $time_parts = is_array($time) ? $time : project_usage_gmgetdate($time);
  $day = $time_parts['mday'] - $time_parts['wday'] + (7 * $weeks_ago);
  return gmmktime(0, 0, 0, $time_parts['mon'], $day, $time_parts['year']);
}

/**
 * Build an array of timestamps for the beginning (midnight Sunday) for each
 * week since a given timestamp.
 *
 * @param $timestamp
 *   UNIX timestamp. The first returned timestamp will be the beginning of the
 *   week with this time in it.
 * @return
 *   An array of GMT timestamps sorted in ascending order. The first value is
 *   is the week containing $timestamp. Each subsequent value is the timestamp
 *   for the next week. The final value is the beginning of the current week.
 */
function project_usage_get_weeks_since($timestamp) {
  $times = array();

  // First, compute the start of the current week so we know when to stop...
  $this_week = project_usage_weekly_timestamp();

  // ...then compute all the weeks up to that.
  $parts = project_usage_gmgetdate($timestamp);
  $i = 0;
  do {
    $times[$i] = project_usage_weekly_timestamp($parts, $i);
  } while ($times[$i++] < $this_week);

  return $times;
}

/**
 * Return an array of the N previous weeks for which we'll have data.
 *
 * @param $count
 *   Number of weeks to return.
 *
 * @return
 *   An array of UNIX timestamps sorted newest to oldest. Will not include
 *   the current week.
 */
function project_usage_get_last_weeks($count = PROJECT_USAGE_SHOW_WEEKS) {
  $weeks = project_usage_get_weeks_since(time() - ($count * PROJECT_USAGE_WEEK));
  // Use array_pop() to remove the current week as we won't have usage data
  // for it.
  array_pop($weeks);
  // Reverse the order so it's newest to oldest.
  return array_reverse($weeks);
}

/**
* Implementation of hook_simpletest().
*/
function project_usage_simpletest() {
  $dir = drupal_get_path('module', 'project_usage'). '/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}

/**
 * Implementation of hook_devel_caches().
 *
 * Lets the devel module know about our cache table so it can clear it.
 */
function project_usage_devel_caches() {
  return array('cache_project_usage');
}

/**
 * Sets the expiry timestamp for cached project usage pages.
 *
 * Default is 24 hours.
 *
 * @return The UNIX timestamp to expire the page at.
 */
function project_usage_cache_time() {
  return time() + variable_get('project_usage_cache_length', 86400);
}

/**
 * Theme the output of project/usage/<project> page.
 *
 * @param $project
 *   A fully loaded $node object for a project.
 * @param $release_header
 *   A table header for the release usage table.
 * @param $release_rows
 *   Table rows for the release usage table.
 * @param $project_header
 *   A table header for the weekly project usage table.
 * @param $project_rows
 *   Table rows for the weekly project usage table.
 */
function theme_project_usage_project_page($project, $release_header = NULL, $release_rows = NULL, $project_header = NULL, $project_rows = NULL) {
  $output = theme('project_usage_header_links', $project);

  if (empty($release_rows)) {
    // There are no published releases for a project that the user has access
    // to view.
    $output .= '<p>'. t('There are no releases for this project.') .'</p>';
    return $output;
  }

  $output .= '<h3>'. t('Recent release usage') .'</h3>';
  $output .= theme('table', $release_header, $release_rows);
  $output .= '<h3>'. t('Weekly project usage') .'</h3>';
  $output .= theme('table', $project_header, $project_rows);
  return $output;
}

/**
 * Theme the output of the project/usage/<release nid> page.
 *
 * @param $project
 *   A fully loaded $node object for a project.
 * @param $release
 *   A fully loaded $node object for a release.
 * @param $header
 *   A table header for the release usage table.
 * @param $rows
 *   Table rows for the release usage table.
 */
function theme_project_usage_release_page($project, $release, $header, $rows) {
  $output = theme('project_usage_header_links', $project, $release);

  // If there is no usage information for a release, don't just
  // display an empty usage table.
  if (empty($rows)) {
    $output .= '<p>' . t('There is no usage information for this release.') . '</p>';
    return $output;
  }

  $output .= theme('table', $header, $rows);
  return $output;
}

/**
 * Create list of links at the top of a usage statistics page.
 *
 * @param $project
 *   A fully loaded $node object for a project.
 * @param $release
 *   If the current statistics page is for a release, the fully loaded $node
 *   object for that release.
 *
 * @return
 *   Themed HTML of a list of links for the top of a statistics page.
 */
function theme_project_usage_header_links($project, $release = NULL) {
  $links = array();
  $links[] = l(t('View %project_name project page', array('%project_name' => $project->title)), 'project/'. $project->uri, array(), NULL, NULL, FALSE, TRUE);
  if (!empty($release)) {
    $links[] = l(t('View %release_name release', array('%release_name' => $release->title)), 'node/' . $release->nid, array(), NULL, NULL, FALSE, TRUE);
    $links[] = l(t('View all %project_name usage statistics', array('%project_name' => $project->title)), 'project/usage/' . $project->uri, array(), NULL, NULL, FALSE, TRUE);
  }
  $links[] = l(t('View usage statistics for all projects'), 'project/usage');
  return theme('item_list', $links);
}

/**
 * Implementation of hook_project_page_link_alter().
 */
function project_usage_project_page_link_alter($node, &$links) {
  if (user_access('view project usage')) {
    $links['resources']['links']['project_usage'] = l(t('View usage statistics'), 'project/usage/' . $node->uri);
  }
}

